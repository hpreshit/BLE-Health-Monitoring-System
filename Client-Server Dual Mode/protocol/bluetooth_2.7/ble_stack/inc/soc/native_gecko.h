


#ifndef NATIVE_GECKO_H
#define NATIVE_GECKO_H

/*****************************************************************************
 *
 *  Native BGAPI for applications in SoC mode
 *
 *  Autogenerated file, do not edit
 *
 ****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifdef HAL_CONFIG
#include "hal-config.h"
#endif

#include <string.h>
#include "bg_types.h"
#include "gecko_configuration.h"

/* Compatibility */
#ifndef PACKSTRUCT
/*Default packed configuration*/
#ifdef __GNUC__
#ifdef _WIN32
#define PACKSTRUCT( decl ) decl __attribute__((__packed__,gcc_struct))
#else
#define PACKSTRUCT( decl ) decl __attribute__((__packed__))
#endif
#define ALIGNED __attribute__((aligned(0x4)))
#elif __IAR_SYSTEMS_ICC__

#define PACKSTRUCT( decl ) __packed decl

#define ALIGNED
#elif _MSC_VER  /*msvc*/

#define PACKSTRUCT( decl ) __pragma( pack(push, 1) ) decl __pragma( pack(pop) )
#define ALIGNED
#else 
#define PACKSTRUCT(a) a PACKED 
#endif
#endif


#define BGLIB_MSG_ID(HDR) ((HDR)&0xffff00f8)
#define BGLIB_MSG_HEADER_LEN (4)
#define BGLIB_MSG_LEN(HDR) ((((HDR)&0x7)<<8)|(((HDR)&0xff00)>>8))


/**
 * Blocks until new event arrives which requires processing by user application.
 * 
 * @return pointer to received event
 */
struct gecko_cmd_packet* gecko_wait_event(void);

/**
 * Same as gecko_wait_event but does not block if no events waiting, instead returns NULL
 *
 * @return pointer to received event or NULL if no event waiting
 */
struct gecko_cmd_packet* gecko_peek_event(void);

/**
 * Events are in queue waiting for processing
 * Call gecko_wait_event or gecko_peek_event to process pending events
 *
 * @return nonzero if processing required
 */
int gecko_event_pending(void);

/**
 *  Initialize stack
 *  @param config if set as NULL uses default values for all configuration parameters
 */
void gecko_stack_init(const gecko_configuration_t *config);

/**
 * Initialize multiprotocol. Please note that multiprotocol version of RAIL
 * is needed.
 * @param config, set to NULL
 */
void gecko_init_multiprotocol(const void *config);


/**
 * Poll the stack how long it can sleep
 * @return maximum sleep time in milliseconds; 0 if cannot sleep
 */
uint32 gecko_can_sleep_ms(void);

/**
 * Poll the stack how long it can sleep
 * @return maximum sleep time in ticks; 0 if cannot sleep
 */
uint32 gecko_can_sleep_ticks(void);

/**
 * Priority message handler function if user application requires the use of PendSV interrupt.
 *
 * If scheduler_callback function pointer in configuration struct is something else than NULL,
 * then stack will not install its own PendSV IRQ handler but instead uses callback/handler functions.
 *
 * When application receives call to the scheduler_callback function it must schedule the call to
 * gecko_priority_handle function to later time to run on high priority thread. This callback
 * may happen inside radio IRQ so processing must not block and has to happen as fast as possible.
 *
 * Recommended implemenation:
 * High priority thread is loop that waits on binary semaphore and calls gecko_priority_handler.
 * The scheduler_callback is simple function that only signals the semaphore.
 *
 */
void gecko_priority_handle(void);

/**
 * Put the stack to sleep for a maximum of @param max milliseconds.
 * Note that the stack may wake up earlier due to an external event.
 * @return number of milliseconds actually slept.
 */
uint32 gecko_sleep_for_ms(uint32 max);

/**
 * Signals stack that external event has happened. Signals can be used to report status change from interrupt
 * context or from other threads to application. Signals are bits that are automatically cleared after
 * application has been notified.
 * 
 * @param signals is a bitmask defining active signals that are reported back to the application by system_external_signal-event.
 *
 */
void gecko_external_signal(uint32 signals);

/**
 * Signals stack to send system_awake event when application received wakeup signal.
 */
void gecko_send_system_awake();

/**
 * Signals stack to send system_error event when in case of an error.
 */
void gecko_send_system_error(uint16 reason, uint8 data_len, const uint8* data);





enum le_gap_address_type
{
    le_gap_address_type_public                                   = 0x0,
    le_gap_address_type_random                                   = 0x1,
    le_gap_address_type_public_identity                          = 0x2,
    le_gap_address_type_random_identity                          = 0x3,
    le_gap_address_type_bredr                                    = 0x10
};

enum le_gap_connectable_mode
{
    le_gap_non_connectable                                       = 0x0,
    le_gap_directed_connectable                                  = 0x1,
    le_gap_undirected_connectable                                = 0x2,
    le_gap_scannable_non_connectable                             = 0x3
};

enum le_gap_discoverable_mode
{
    le_gap_non_discoverable                                      = 0x0,
    le_gap_limited_discoverable                                  = 0x1,
    le_gap_general_discoverable                                  = 0x2,
    le_gap_broadcast                                             = 0x3,
    le_gap_user_data                                             = 0x4
};

enum le_gap_discover_mode
{
    le_gap_discover_limited                                      = 0x0,
    le_gap_discover_generic                                      = 0x1,
    le_gap_discover_observation                                  = 0x2
};

enum le_gap_adv_address_type
{
    le_gap_identity_address                                      = 0x0,
    le_gap_non_resolvable                                        = 0x1
};

enum le_connection_security
{
    le_connection_mode1_level1                                   = 0x0,
    le_connection_mode1_level2                                   = 0x1,
    le_connection_mode1_level3                                   = 0x2,
    le_connection_mode1_level4                                   = 0x3
};

enum gatt_att_opcode
{
    gatt_read_by_type_request                                    = 0x8,
    gatt_read_by_type_response                                   = 0x9,
    gatt_read_request                                            = 0xa,
    gatt_read_response                                           = 0xb,
    gatt_read_blob_request                                       = 0xc,
    gatt_read_blob_response                                      = 0xd,
    gatt_read_multiple_request                                   = 0xe,
    gatt_read_multiple_response                                  = 0xf,
    gatt_write_request                                           = 0x12,
    gatt_write_response                                          = 0x13,
    gatt_write_command                                           = 0x52,
    gatt_prepare_write_request                                   = 0x16,
    gatt_prepare_write_response                                  = 0x17,
    gatt_execute_write_request                                   = 0x18,
    gatt_execute_write_response                                  = 0x19,
    gatt_handle_value_notification                               = 0x1b,
    gatt_handle_value_indication                                 = 0x1d
};

enum gatt_client_config_flag
{
    gatt_disable                                                 = 0x0,
    gatt_notification                                            = 0x1,
    gatt_indication                                              = 0x2
};

enum gatt_execute_write_flag
{
    gatt_cancel                                                  = 0x0,
    gatt_commit                                                  = 0x1
};

enum gatt_server_characteristic_status_flag
{
    gatt_server_client_config                                    = 0x1,
    gatt_server_confirmation                                     = 0x2
};


enum test_packet_type
{
    test_pkt_prbs9                                               = 0x0,
    test_pkt_11110000                                            = 0x1,
    test_pkt_10101010                                            = 0x2,
    test_pkt_carrier_deprecated                                  = 0x3,
    test_pkt_pn9                                                 = 0xfd,
    test_pkt_carrier                                             = 0xfe
};

enum test_phy
{
    test_phy_1m                                                  = 0x1,
    test_phy_2m                                                  = 0x2,
    test_phy_125k                                                = 0x3,
    test_phy_500k                                                = 0x4
};

enum sm_bonding_key
{
    sm_bonding_key_ltk                                           = 0x1,
    sm_bonding_key_addr_public                                   = 0x2,
    sm_bonding_key_addr_static                                   = 0x4,
    sm_bonding_key_irk                                           = 0x8,
    sm_bonding_key_edivrand                                      = 0x10,
    sm_bonding_key_csrk                                          = 0x20,
    sm_bonding_key_masterid                                      = 0x40
};

enum sm_io_capability
{
    sm_io_capability_displayonly                                 = 0x0,
    sm_io_capability_displayyesno                                = 0x1,
    sm_io_capability_keyboardonly                                = 0x2,
    sm_io_capability_noinputnooutput                             = 0x3,
    sm_io_capability_keyboarddisplay                             = 0x4
};

enum homekit_category
{
    homekit_not_allowed                                          = 0x0,
    homekit_other                                                = 0x1,
    homekit_bridge                                               = 0x2,
    homekit_fan                                                  = 0x3,
    homekit_garage                                               = 0x4,
    homekit_lightbulb                                            = 0x5,
    homekit_doorlock                                             = 0x6,
    homekit_outlet                                               = 0x7,
    homekit_switch_accessory                                     = 0x8,
    homekit_thermostat                                           = 0x9,
    homekit_sensor                                               = 0xa,
    homekit_security_system                                      = 0xb,
    homekit_door                                                 = 0xc,
    homekit_window                                               = 0xd,
    homekit_window_covering                                      = 0xe,
    homekit_programmable_switch                                  = 0xf,
    homekit_ip_camera                                            = 0x11,
    homekit_video_door_bell                                      = 0x12,
    homekit_air_purifier                                         = 0x13,
    homekit_heater                                               = 0x14,
    homekit_air_conditioner                                      = 0x15,
    homekit_humidifier                                           = 0x16,
    homekit_dehumidifier                                         = 0x17
};

enum homekit_status_code
{
    homekit_success                                              = 0x0,
    homekit_invalid_request                                      = 0x6
};

enum coex_option
{
    coex_option_enable                                           = 0x100,
    coex_option_tx_abort                                         = 0x400,
    coex_option_high_priority                                    = 0x800
};

enum gecko_parameter_types
{
    gecko_msg_parameter_uint8=2,
    gecko_msg_parameter_int8=3,
    gecko_msg_parameter_uint16=4,
    gecko_msg_parameter_int16=5,
    gecko_msg_parameter_uint32=6,
    gecko_msg_parameter_int32=7,
    gecko_msg_parameter_uint8array=8,
    gecko_msg_parameter_string=9,
    gecko_msg_parameter_hwaddr=10,
    gecko_msg_parameter_uint16array=11
};

enum gecko_msg_types
{
    gecko_msg_type_cmd=0x00,
    gecko_msg_type_rsp=0x00,
    gecko_msg_type_evt=0x80
};
enum gecko_dev_types
{
    gecko_dev_type_gecko   =0x20
};



#define FLASH_PS_KEY_BD_ADDR                                         0x1
#define FLASH_PS_KEY_LOCAL_NAME                                      0x4
#define FLASH_PS_KEY_BT_CLASS                                        0x5
#define FLASH_PS_KEY_IWRAP_PAGE_MODE                                 0x6
#define FLASH_PS_KEY_IWRAP_PAGE_TIMEOUT                              0x7
#define FLASH_PS_KEY_IWRAP_PAGE_SCAN_MODE                            0x8
#define FLASH_PS_KEY_IWRAP_ALT_PAGE_MODE                             0x9
#define FLASH_PS_KEY_IWRAP_PAGE_CONN_COUNT                           0xa
#define FLASH_PS_KEY_IWRAP_MS_POLICY                                 0xb
#define FLASH_PS_KEY_IWRAP_LINK_POLICY                               0xc
#define FLASH_PS_KEY_IWRAP_SUPERVISION_TIMEOUT                       0xd
#define FLASH_PS_KEY_SNIFF_MAX_INTERVAL                              0xe
#define FLASH_PS_KEY_SNIFF_MIN_INTERVAL                              0xf
#define FLASH_PS_KEY_SNIFF_ATTEMPTS                                  0x10
#define FLASH_PS_KEY_SNIFF_TIMEOUT                                   0x11
#define FLASH_PS_KEY_IO_CAPABILITIES                                 0x12
#define FLASH_PS_KEY_MITM                                            0x13
#define FLASH_PS_KEY_IWRAP_CONTROL_ECHO                              0x14
#define FLASH_PS_KEY_UART_SPEED                                      0x15
#define FLASH_PS_KEY_PROFILE_SPP                                     0x16
#define FLASH_PS_KEY_PORTA_PIO_DIRECTION                             0x17
#define FLASH_PS_KEY_PORTB_PIO_DIRECTION                             0x18
#define FLASH_PS_KEY_PORTA_PIO_BIAS                                  0x19
#define FLASH_PS_KEY_PORTB_PIO_BIAS                                  0x1a
#define FLASH_PS_KEY_PORTA_PIO_PULL_UP                               0x1b
#define FLASH_PS_KEY_PORTB_PIO_PULL_UP                               0x1c
#define FLASH_PS_KEY_IWRAP_I2C_STATUS                                0x1d
#define FLASH_PS_KEY_IWRAP_SPI_STATUS                                0x1e
#define FLASH_PS_KEY_MAXPAIRCOUNT                                    0x1f
#define FLASH_PS_KEY_LAST_DELETED_PAIR                               0x20
#define FLASH_PS_KEY_IWRAP_CD_MASK                                   0x21
#define FLASH_PS_KEY_IWRAP_CD_DATA_MASK                              0x22
#define FLASH_PS_KEY_IWRAP_CD_MODE                                   0x23
#define FLASH_PS_KEY_IWRAP_AUTH_PIN_VISIBLE                          0x24
#define FLASH_PS_KEY_AUTH_PIN                                        0x25
#define FLASH_PS_KEY_IWRAP_READY_MASK                                0x26
#define FLASH_PS_KEY_IWRAP_ESC_CHAR                                  0x27
#define FLASH_PS_KEY_IWRAP_DTR_PIO_MASK                              0x28
#define FLASH_PS_KEY_IWRAP_DTR_MODE                                  0x29
#define FLASH_PS_KEY_MINIMUM_ENCRYPTION_KEY_SIZE                     0x2a
#define FLASH_PS_KEY_INQUIRY_SCAN_LAP                                0x2b
#define FLASH_PS_KEY_LOCAL_BD_ADDR                                   0x2c
#define FLASH_PS_KEY_AUTOCALL                                        0x2d
#define FLASH_PS_KEY_AUTOCALL_DUMMY                                  0x2e
#define FLASH_PS_KEY_LAP                                             0x2f
#define FLASH_PS_KEY_CONNAUTH                                        0x30
#define FLASH_PS_KEY_TX_POWER                                        0x31
#define FLASH_PS_KEY_CTUNE                                           0x32
#define FLASH_PS_KEY_APPLICATION_GSN                                 0x33
#define FLASH_PS_KEY_CTUNE_LAST                                      0x34
#define FLASH_PS_KEY_OTA_FLAGS                                       0x35
#define FLASH_PS_KEY_OTA_DEVICE_NAME                                 0x36
#define FLASH_PS_KEY_DEVICE_IRK                                      0x37
#define FLASH_PS_KEY_BONDING_PRIORITY_LIST                           0x38
#define FLASH_PS_KEY_OTA_ADVERTISEMENT_PACKET                        0x39
#define FLASH_PS_KEY_OTA_SCAN_RESPONSE_PACKET                        0x3a
#define FLASH_PS_KEY_APPLICATION_AI                                  0x3b
#define FLASH_PS_KEY_BONDING_DB_CONFIG                               0x3fff


#define gecko_cmd_dfu_reset_id                                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00000000)
#define gecko_cmd_dfu_flash_set_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01000000)
#define gecko_cmd_dfu_flash_upload_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02000000)
#define gecko_cmd_dfu_flash_upload_finish_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03000000)
#define gecko_cmd_system_hello_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00010000)
#define gecko_cmd_system_reset_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01010000)
#define gecko_cmd_system_get_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03010000)
#define gecko_cmd_system_set_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04010000)
#define gecko_cmd_system_set_tx_power_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a010000)
#define gecko_cmd_system_get_random_data_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b010000)
#define gecko_cmd_system_halt_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c010000)
#define gecko_cmd_system_set_device_name_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d010000)
#define gecko_cmd_system_linklayer_configure_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e010000)
#define gecko_cmd_le_gap_open_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00030000)
#define gecko_cmd_le_gap_set_mode_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01030000)
#define gecko_cmd_le_gap_discover_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02030000)
#define gecko_cmd_le_gap_end_procedure_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03030000)
#define gecko_cmd_le_gap_set_adv_parameters_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04030000)
#define gecko_cmd_le_gap_set_conn_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05030000)
#define gecko_cmd_le_gap_set_scan_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06030000)
#define gecko_cmd_le_gap_set_adv_data_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07030000)
#define gecko_cmd_le_gap_set_adv_timeout_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08030000)
#define gecko_cmd_le_gap_set_phy_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09030000)
#define gecko_cmd_le_gap_bt5_set_mode_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a030000)
#define gecko_cmd_le_gap_bt5_set_adv_parameters_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b030000)
#define gecko_cmd_le_gap_bt5_set_adv_data_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c030000)
#define gecko_cmd_le_gap_set_privacy_mode_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d030000)
#define gecko_cmd_le_connection_set_parameters_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00080000)
#define gecko_cmd_le_connection_get_rssi_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01080000)
#define gecko_cmd_le_connection_disable_slave_latency_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02080000)
#define gecko_cmd_le_connection_set_phy_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03080000)
#define gecko_cmd_le_connection_close_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04080000)
#define gecko_cmd_gatt_set_max_mtu_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00090000)
#define gecko_cmd_gatt_discover_primary_services_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01090000)
#define gecko_cmd_gatt_discover_primary_services_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02090000)
#define gecko_cmd_gatt_discover_characteristics_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03090000)
#define gecko_cmd_gatt_discover_characteristics_by_uuid_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04090000)
#define gecko_cmd_gatt_set_characteristic_notification_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05090000)
#define gecko_cmd_gatt_discover_descriptors_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06090000)
#define gecko_cmd_gatt_read_characteristic_value_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07090000)
#define gecko_cmd_gatt_read_characteristic_value_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08090000)
#define gecko_cmd_gatt_write_characteristic_value_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09090000)
#define gecko_cmd_gatt_write_characteristic_value_without_response_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a090000)
#define gecko_cmd_gatt_prepare_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b090000)
#define gecko_cmd_gatt_execute_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c090000)
#define gecko_cmd_gatt_send_characteristic_confirmation_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d090000)
#define gecko_cmd_gatt_read_descriptor_value_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e090000)
#define gecko_cmd_gatt_write_descriptor_value_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f090000)
#define gecko_cmd_gatt_find_included_services_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x10090000)
#define gecko_cmd_gatt_read_multiple_characteristic_values_id         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x11090000)
#define gecko_cmd_gatt_read_characteristic_value_from_offset_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x12090000)
#define gecko_cmd_gatt_prepare_characteristic_value_reliable_write_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x13090000)
#define gecko_cmd_gatt_server_read_attribute_value_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000a0000)
#define gecko_cmd_gatt_server_read_attribute_type_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010a0000)
#define gecko_cmd_gatt_server_write_attribute_value_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020a0000)
#define gecko_cmd_gatt_server_send_user_read_response_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030a0000)
#define gecko_cmd_gatt_server_send_user_write_response_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040a0000)
#define gecko_cmd_gatt_server_send_characteristic_notification_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x050a0000)
#define gecko_cmd_gatt_server_find_attribute_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060a0000)
#define gecko_cmd_gatt_server_set_database_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070a0000)
#define gecko_cmd_gatt_server_set_capabilities_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x080a0000)
#define gecko_cmd_endpoint_close_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020b0000)
#define gecko_cmd_hardware_set_soft_timer_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000c0000)
#define gecko_cmd_hardware_get_time_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b0c0000)
#define gecko_cmd_hardware_set_lazy_soft_timer_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c0c0000)
#define gecko_cmd_hardware_enable_dcdc_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d0c0000)
#define gecko_cmd_flash_ps_dump_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000d0000)
#define gecko_cmd_flash_ps_erase_all_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010d0000)
#define gecko_cmd_flash_ps_save_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020d0000)
#define gecko_cmd_flash_ps_load_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030d0000)
#define gecko_cmd_flash_ps_erase_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040d0000)
#define gecko_cmd_test_dtm_tx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000e0000)
#define gecko_cmd_test_dtm_rx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010e0000)
#define gecko_cmd_test_dtm_end_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020e0000)
#define gecko_cmd_test_debug_command_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070e0000)
#define gecko_cmd_test_debug_counter_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c0e0000)
#define gecko_cmd_sm_set_bondable_mode_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000f0000)
#define gecko_cmd_sm_configure_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010f0000)
#define gecko_cmd_sm_store_bonding_configuration_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020f0000)
#define gecko_cmd_sm_increase_security_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040f0000)
#define gecko_cmd_sm_delete_bonding_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060f0000)
#define gecko_cmd_sm_delete_bondings_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070f0000)
#define gecko_cmd_sm_enter_passkey_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x080f0000)
#define gecko_cmd_sm_passkey_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x090f0000)
#define gecko_cmd_sm_set_oob_data_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a0f0000)
#define gecko_cmd_sm_list_all_bondings_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b0f0000)
#define gecko_cmd_sm_bonding_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e0f0000)
#define gecko_cmd_sm_set_debug_mode_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f0f0000)
#define gecko_cmd_sm_set_passkey_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x100f0000)
#define gecko_cmd_sm_use_sc_oob_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x110f0000)
#define gecko_cmd_sm_set_sc_remote_oob_data_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x120f0000)
#define gecko_cmd_homekit_configure_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00130000)
#define gecko_cmd_homekit_advertise_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01130000)
#define gecko_cmd_homekit_delete_pairings_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02130000)
#define gecko_cmd_homekit_check_authcp_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03130000)
#define gecko_cmd_homekit_get_pairing_id_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04130000)
#define gecko_cmd_homekit_send_write_response_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05130000)
#define gecko_cmd_homekit_send_read_response_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06130000)
#define gecko_cmd_homekit_gsn_action_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07130000)
#define gecko_cmd_homekit_event_notification_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08130000)
#define gecko_cmd_homekit_broadcast_action_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09130000)
#define gecko_cmd_coex_set_options_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00200000)
#define gecko_cmd_coex_get_counters_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01200000)
#define gecko_cmd_experiment_set_coded_phy_advertising_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00210000)
#define gecko_cmd_experiment_set_coded_phy_discovery_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01210000)
#define gecko_cmd_user_message_to_target_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00ff0000)

#define gecko_rsp_dfu_flash_set_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01000000)
#define gecko_rsp_dfu_flash_upload_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02000000)
#define gecko_rsp_dfu_flash_upload_finish_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03000000)
#define gecko_rsp_system_hello_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00010000)
#define gecko_rsp_system_get_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03010000)
#define gecko_rsp_system_set_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04010000)
#define gecko_rsp_system_set_tx_power_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a010000)
#define gecko_rsp_system_get_random_data_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b010000)
#define gecko_rsp_system_halt_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c010000)
#define gecko_rsp_system_set_device_name_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d010000)
#define gecko_rsp_system_linklayer_configure_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e010000)
#define gecko_rsp_le_gap_open_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00030000)
#define gecko_rsp_le_gap_set_mode_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01030000)
#define gecko_rsp_le_gap_discover_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02030000)
#define gecko_rsp_le_gap_end_procedure_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03030000)
#define gecko_rsp_le_gap_set_adv_parameters_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04030000)
#define gecko_rsp_le_gap_set_conn_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05030000)
#define gecko_rsp_le_gap_set_scan_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06030000)
#define gecko_rsp_le_gap_set_adv_data_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07030000)
#define gecko_rsp_le_gap_set_adv_timeout_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08030000)
#define gecko_rsp_le_gap_set_phy_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09030000)
#define gecko_rsp_le_gap_bt5_set_mode_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a030000)
#define gecko_rsp_le_gap_bt5_set_adv_parameters_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b030000)
#define gecko_rsp_le_gap_bt5_set_adv_data_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c030000)
#define gecko_rsp_le_gap_set_privacy_mode_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d030000)
#define gecko_rsp_le_connection_set_parameters_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00080000)
#define gecko_rsp_le_connection_get_rssi_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01080000)
#define gecko_rsp_le_connection_disable_slave_latency_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02080000)
#define gecko_rsp_le_connection_set_phy_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03080000)
#define gecko_rsp_le_connection_close_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04080000)
#define gecko_rsp_gatt_set_max_mtu_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00090000)
#define gecko_rsp_gatt_discover_primary_services_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01090000)
#define gecko_rsp_gatt_discover_primary_services_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02090000)
#define gecko_rsp_gatt_discover_characteristics_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03090000)
#define gecko_rsp_gatt_discover_characteristics_by_uuid_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04090000)
#define gecko_rsp_gatt_set_characteristic_notification_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05090000)
#define gecko_rsp_gatt_discover_descriptors_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06090000)
#define gecko_rsp_gatt_read_characteristic_value_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07090000)
#define gecko_rsp_gatt_read_characteristic_value_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08090000)
#define gecko_rsp_gatt_write_characteristic_value_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09090000)
#define gecko_rsp_gatt_write_characteristic_value_without_response_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a090000)
#define gecko_rsp_gatt_prepare_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b090000)
#define gecko_rsp_gatt_execute_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c090000)
#define gecko_rsp_gatt_send_characteristic_confirmation_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d090000)
#define gecko_rsp_gatt_read_descriptor_value_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e090000)
#define gecko_rsp_gatt_write_descriptor_value_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f090000)
#define gecko_rsp_gatt_find_included_services_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x10090000)
#define gecko_rsp_gatt_read_multiple_characteristic_values_id         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x11090000)
#define gecko_rsp_gatt_read_characteristic_value_from_offset_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x12090000)
#define gecko_rsp_gatt_prepare_characteristic_value_reliable_write_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x13090000)
#define gecko_rsp_gatt_server_read_attribute_value_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000a0000)
#define gecko_rsp_gatt_server_read_attribute_type_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010a0000)
#define gecko_rsp_gatt_server_write_attribute_value_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020a0000)
#define gecko_rsp_gatt_server_send_user_read_response_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030a0000)
#define gecko_rsp_gatt_server_send_user_write_response_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040a0000)
#define gecko_rsp_gatt_server_send_characteristic_notification_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x050a0000)
#define gecko_rsp_gatt_server_find_attribute_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060a0000)
#define gecko_rsp_gatt_server_set_database_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070a0000)
#define gecko_rsp_gatt_server_set_capabilities_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x080a0000)
#define gecko_rsp_endpoint_close_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020b0000)
#define gecko_rsp_hardware_set_soft_timer_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000c0000)
#define gecko_rsp_hardware_get_time_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b0c0000)
#define gecko_rsp_hardware_set_lazy_soft_timer_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c0c0000)
#define gecko_rsp_hardware_enable_dcdc_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d0c0000)
#define gecko_rsp_flash_ps_dump_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000d0000)
#define gecko_rsp_flash_ps_erase_all_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010d0000)
#define gecko_rsp_flash_ps_save_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020d0000)
#define gecko_rsp_flash_ps_load_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030d0000)
#define gecko_rsp_flash_ps_erase_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040d0000)
#define gecko_rsp_test_dtm_tx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000e0000)
#define gecko_rsp_test_dtm_rx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010e0000)
#define gecko_rsp_test_dtm_end_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020e0000)
#define gecko_rsp_test_debug_command_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070e0000)
#define gecko_rsp_test_debug_counter_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c0e0000)
#define gecko_rsp_sm_set_bondable_mode_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000f0000)
#define gecko_rsp_sm_configure_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010f0000)
#define gecko_rsp_sm_store_bonding_configuration_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020f0000)
#define gecko_rsp_sm_increase_security_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040f0000)
#define gecko_rsp_sm_delete_bonding_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060f0000)
#define gecko_rsp_sm_delete_bondings_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070f0000)
#define gecko_rsp_sm_enter_passkey_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x080f0000)
#define gecko_rsp_sm_passkey_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x090f0000)
#define gecko_rsp_sm_set_oob_data_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a0f0000)
#define gecko_rsp_sm_list_all_bondings_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b0f0000)
#define gecko_rsp_sm_bonding_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e0f0000)
#define gecko_rsp_sm_set_debug_mode_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f0f0000)
#define gecko_rsp_sm_set_passkey_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x100f0000)
#define gecko_rsp_sm_use_sc_oob_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x110f0000)
#define gecko_rsp_sm_set_sc_remote_oob_data_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x120f0000)
#define gecko_rsp_homekit_configure_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00130000)
#define gecko_rsp_homekit_advertise_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01130000)
#define gecko_rsp_homekit_delete_pairings_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02130000)
#define gecko_rsp_homekit_check_authcp_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03130000)
#define gecko_rsp_homekit_get_pairing_id_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04130000)
#define gecko_rsp_homekit_send_write_response_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05130000)
#define gecko_rsp_homekit_send_read_response_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06130000)
#define gecko_rsp_homekit_gsn_action_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07130000)
#define gecko_rsp_homekit_event_notification_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08130000)
#define gecko_rsp_homekit_broadcast_action_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09130000)
#define gecko_rsp_coex_set_options_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00200000)
#define gecko_rsp_coex_get_counters_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01200000)
#define gecko_rsp_experiment_set_coded_phy_advertising_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00210000)
#define gecko_rsp_experiment_set_coded_phy_discovery_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01210000)
#define gecko_rsp_user_message_to_target_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00ff0000)

#define gecko_evt_dfu_boot_id                                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00000000)
#define gecko_evt_dfu_boot_failure_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01000000)
#define gecko_evt_system_boot_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00010000)
#define gecko_evt_system_external_signal_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03010000)
#define gecko_evt_system_awake_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04010000)
#define gecko_evt_system_hardware_error_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05010000)
#define gecko_evt_system_error_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06010000)
#define gecko_evt_le_gap_scan_response_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00030000)
#define gecko_evt_le_gap_adv_timeout_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01030000)
#define gecko_evt_le_gap_scan_request_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02030000)
#define gecko_evt_le_gap_bt5_adv_timeout_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03030000)
#define gecko_evt_le_connection_opened_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00080000)
#define gecko_evt_le_connection_closed_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01080000)
#define gecko_evt_le_connection_parameters_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02080000)
#define gecko_evt_le_connection_rssi_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03080000)
#define gecko_evt_le_connection_phy_status_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04080000)
#define gecko_evt_le_connection_bt5_opened_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05080000)
#define gecko_evt_gatt_mtu_exchanged_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00090000)
#define gecko_evt_gatt_service_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01090000)
#define gecko_evt_gatt_characteristic_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02090000)
#define gecko_evt_gatt_descriptor_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03090000)
#define gecko_evt_gatt_characteristic_value_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04090000)
#define gecko_evt_gatt_descriptor_value_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05090000)
#define gecko_evt_gatt_procedure_completed_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06090000)
#define gecko_evt_gatt_server_attribute_value_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000a0000)
#define gecko_evt_gatt_server_user_read_request_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010a0000)
#define gecko_evt_gatt_server_user_write_request_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020a0000)
#define gecko_evt_gatt_server_characteristic_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030a0000)
#define gecko_evt_gatt_server_execute_write_completed_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x040a0000)
#define gecko_evt_endpoint_status_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020b0000)
#define gecko_evt_hardware_soft_timer_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000c0000)
#define gecko_evt_flash_ps_key_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000d0000)
#define gecko_evt_test_dtm_completed_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000e0000)
#define gecko_evt_test_hcidump_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020e0000)
#define gecko_evt_sm_passkey_display_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000f0000)
#define gecko_evt_sm_passkey_request_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010f0000)
#define gecko_evt_sm_confirm_passkey_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020f0000)
#define gecko_evt_sm_bonded_id                                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030f0000)
#define gecko_evt_sm_bonding_failed_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x040f0000)
#define gecko_evt_sm_list_bonding_entry_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x050f0000)
#define gecko_evt_sm_list_all_bondings_complete_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x060f0000)
#define gecko_evt_sm_confirm_bonding_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x090f0000)
#define gecko_evt_homekit_setupcode_display_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00130000)
#define gecko_evt_homekit_paired_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01130000)
#define gecko_evt_homekit_pair_verified_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02130000)
#define gecko_evt_homekit_connection_opened_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03130000)
#define gecko_evt_homekit_connection_closed_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04130000)
#define gecko_evt_homekit_identify_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05130000)
#define gecko_evt_homekit_write_request_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06130000)
#define gecko_evt_homekit_read_request_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x07130000)
#define gecko_evt_homekit_disconnection_required_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x08130000)
#define gecko_evt_homekit_pairing_removed_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x09130000)
#define gecko_evt_homekit_setuppayload_display_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x0a130000)
#define gecko_evt_user_message_to_host_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00ff0000)

#include "bg_errorcodes.h"

PACKSTRUCT( struct gecko_msg_dfu_reset_cmd_t
{
    uint8               dfu;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_set_address_cmd_t
{
    uint32              address;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_set_address_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_upload_cmd_t
{
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_upload_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_upload_finish_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_dfu_boot_evt_t
{
    uint32              version;
});
PACKSTRUCT( struct gecko_msg_dfu_boot_failure_evt_t
{
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_system_hello_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_reset_cmd_t
{
    uint8               dfu;
});
PACKSTRUCT( struct gecko_msg_system_get_bt_address_rsp_t
{
    bd_addr             address;
});
PACKSTRUCT( struct gecko_msg_system_set_bt_address_cmd_t
{
    bd_addr             address;
});
PACKSTRUCT( struct gecko_msg_system_set_bt_address_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_set_tx_power_cmd_t
{
    int16               power;
});
PACKSTRUCT( struct gecko_msg_system_set_tx_power_rsp_t
{
    int16               set_power;
});
PACKSTRUCT( struct gecko_msg_system_get_random_data_cmd_t
{
    uint8               length;
});
PACKSTRUCT( struct gecko_msg_system_get_random_data_rsp_t
{
    uint16              result;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_system_halt_cmd_t
{
    uint8               halt;
});
PACKSTRUCT( struct gecko_msg_system_halt_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_set_device_name_cmd_t
{
    uint8               type;
    uint8array          name;
});
PACKSTRUCT( struct gecko_msg_system_set_device_name_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_linklayer_configure_cmd_t
{
    uint8               key;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_system_linklayer_configure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_boot_evt_t
{
    uint16              major;
    uint16              minor;
    uint16              patch;
    uint16              build;
    uint32              bootloader;
    uint16              hw;
});
PACKSTRUCT( struct gecko_msg_system_external_signal_evt_t
{
    uint32              extsignals;
});
PACKSTRUCT( struct gecko_msg_system_hardware_error_evt_t
{
    uint16              status;
});
PACKSTRUCT( struct gecko_msg_system_error_evt_t
{
    uint16              reason;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_le_gap_open_cmd_t
{
    bd_addr             address;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_le_gap_open_rsp_t
{
    uint16              result;
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_mode_cmd_t
{
    uint8               discover;
    uint8               connect;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_discover_cmd_t
{
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_le_gap_discover_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_end_procedure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_parameters_cmd_t
{
    uint16              interval_min;
    uint16              interval_max;
    uint8               channel_map;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_conn_parameters_cmd_t
{
    uint16              min_interval;
    uint16              max_interval;
    uint16              latency;
    uint16              timeout;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_conn_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_scan_parameters_cmd_t
{
    uint16              scan_interval;
    uint16              scan_window;
    uint8               active;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_scan_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_data_cmd_t
{
    uint8               scan_rsp;
    uint8array          adv_data;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_timeout_cmd_t
{
    uint8               intervals;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_timeout_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_phy_cmd_t
{
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_phy_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_mode_cmd_t
{
    uint8               handle;
    uint8               discover;
    uint8               connect;
    uint16              maxevents;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_parameters_cmd_t
{
    uint8               handle;
    uint16              interval_min;
    uint16              interval_max;
    uint8               channel_map;
    uint8               report_scan;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_data_cmd_t
{
    uint8               handle;
    uint8               scan_rsp;
    uint8array          adv_data;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_privacy_mode_cmd_t
{
    uint8               privacy;
    uint8               interval;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_privacy_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_scan_response_evt_t
{
    int8                rssi;
    uint8               packet_type;
    bd_addr             address;
    uint8               address_type;
    uint8               bonding;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_le_gap_scan_request_evt_t
{
    uint8               handle;
    bd_addr             address;
    uint8               address_type;
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_adv_timeout_evt_t
{
    uint8               handle;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_parameters_cmd_t
{
    uint8               connection;
    uint16              min_interval;
    uint16              max_interval;
    uint16              latency;
    uint16              timeout;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_get_rssi_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_connection_get_rssi_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_disable_slave_latency_cmd_t
{
    uint8               connection;
    uint8               disable;
});
PACKSTRUCT( struct gecko_msg_le_connection_disable_slave_latency_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_phy_cmd_t
{
    uint8               connection;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_phy_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_close_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_connection_close_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_opened_evt_t
{
    bd_addr             address;
    uint8               address_type;
    uint8               master;
    uint8               connection;
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_le_connection_closed_evt_t
{
    uint16              reason;
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_connection_parameters_evt_t
{
    uint8               connection;
    uint16              interval;
    uint16              latency;
    uint16              timeout;
    uint8               security_mode;
    uint16              txsize;
});
PACKSTRUCT( struct gecko_msg_le_connection_rssi_evt_t
{
    uint8               connection;
    uint8               status;
    int8                rssi;
});
PACKSTRUCT( struct gecko_msg_le_connection_phy_status_evt_t
{
    uint8               connection;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_le_connection_bt5_opened_evt_t
{
    bd_addr             address;
    uint8               address_type;
    uint8               master;
    uint8               connection;
    uint8               bonding;
    uint8               advertiser;
});
PACKSTRUCT( struct gecko_msg_gatt_set_max_mtu_cmd_t
{
    uint16              max_mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_set_max_mtu_rsp_t
{
    uint16              result;
    uint16              max_mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_by_uuid_cmd_t
{
    uint8               connection;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_cmd_t
{
    uint8               connection;
    uint32              service;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_by_uuid_cmd_t
{
    uint8               connection;
    uint32              service;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_set_characteristic_notification_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               flags;
});
PACKSTRUCT( struct gecko_msg_gatt_set_characteristic_notification_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_descriptors_cmd_t
{
    uint8               connection;
    uint16              characteristic;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_descriptors_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_cmd_t
{
    uint8               connection;
    uint16              characteristic;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_by_uuid_cmd_t
{
    uint8               connection;
    uint32              service;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_without_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_write_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_execute_characteristic_value_write_cmd_t
{
    uint8               connection;
    uint8               flags;
});
PACKSTRUCT( struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_send_characteristic_confirmation_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_descriptor_value_cmd_t
{
    uint8               connection;
    uint16              descriptor;
});
PACKSTRUCT( struct gecko_msg_gatt_read_descriptor_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_write_descriptor_value_cmd_t
{
    uint8               connection;
    uint16              descriptor;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_write_descriptor_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_find_included_services_cmd_t
{
    uint8               connection;
    uint32              service;
});
PACKSTRUCT( struct gecko_msg_gatt_find_included_services_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_multiple_characteristic_values_cmd_t
{
    uint8               connection;
    uint8array          characteristic_list;
});
PACKSTRUCT( struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_from_offset_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
    uint16              maxlen;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_from_offset_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_mtu_exchanged_evt_t
{
    uint8               connection;
    uint16              mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_service_evt_t
{
    uint8               connection;
    uint32              service;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_characteristic_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               properties;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_descriptor_evt_t
{
    uint8               connection;
    uint16              descriptor;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_characteristic_value_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_opcode;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_descriptor_value_evt_t
{
    uint8               connection;
    uint16              descriptor;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_procedure_completed_evt_t
{
    uint8               connection;
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_value_cmd_t
{
    uint16              attribute;
    uint16              offset;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_value_rsp_t
{
    uint16              result;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_type_cmd_t
{
    uint16              attribute;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_type_rsp_t
{
    uint16              result;
    uint8array          type;
});
PACKSTRUCT( struct gecko_msg_gatt_server_write_attribute_value_cmd_t
{
    uint16              attribute;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_write_attribute_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_read_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_errorcode;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_read_response_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_write_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_errorcode;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_write_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_characteristic_notification_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_server_find_attribute_cmd_t
{
    uint16              start;
    uint8array          type;
});
PACKSTRUCT( struct gecko_msg_gatt_server_find_attribute_rsp_t
{
    uint16              result;
    uint16              attribute;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_database_cmd_t
{
    uint32              ptr;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_database_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_capabilities_cmd_t
{
    uint32              caps;
    uint32              reserved;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_capabilities_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_attribute_value_evt_t
{
    uint8               connection;
    uint16              attribute;
    uint8               att_opcode;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_user_read_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_opcode;
    uint16              offset;
});
PACKSTRUCT( struct gecko_msg_gatt_server_user_write_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_opcode;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_characteristic_status_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               status_flags;
    uint16              client_config_flags;
});
PACKSTRUCT( struct gecko_msg_gatt_server_execute_write_completed_evt_t
{
    uint8               connection;
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_endpoint_close_cmd_t
{
    uint8               endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_close_rsp_t
{
    uint16              result;
    uint8               endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_status_evt_t
{
    uint8               endpoint;
    uint32              type;
    int8                destination_endpoint;
    uint8               flags;
});
PACKSTRUCT( struct gecko_msg_hardware_set_soft_timer_cmd_t
{
    uint32              time;
    uint8               handle;
    uint8               single_shot;
});
PACKSTRUCT( struct gecko_msg_hardware_set_soft_timer_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_hardware_get_time_rsp_t
{
    uint32              seconds;
    uint16              ticks;
});
PACKSTRUCT( struct gecko_msg_hardware_set_lazy_soft_timer_cmd_t
{
    uint32              time;
    uint32              slack;
    uint8               handle;
    uint8               single_shot;
});
PACKSTRUCT( struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_hardware_enable_dcdc_cmd_t
{
    uint8               enable;
});
PACKSTRUCT( struct gecko_msg_hardware_enable_dcdc_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_hardware_soft_timer_evt_t
{
    uint8               handle;
});
PACKSTRUCT( struct gecko_msg_flash_ps_dump_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_flash_ps_erase_all_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_flash_ps_save_cmd_t
{
    uint16              key;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_flash_ps_save_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_flash_ps_load_cmd_t
{
    uint16              key;
});
PACKSTRUCT( struct gecko_msg_flash_ps_load_rsp_t
{
    uint16              result;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_flash_ps_erase_cmd_t
{
    uint16              key;
});
PACKSTRUCT( struct gecko_msg_flash_ps_erase_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_flash_ps_key_evt_t
{
    uint16              key;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_test_dtm_tx_cmd_t
{
    uint8               packet_type;
    uint8               length;
    uint8               channel;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_test_dtm_tx_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_test_dtm_rx_cmd_t
{
    uint8               channel;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_test_dtm_rx_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_test_dtm_end_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_test_debug_command_cmd_t
{
    uint8               id;
    uint8array          debugdata;
});
PACKSTRUCT( struct gecko_msg_test_debug_command_rsp_t
{
    uint16              result;
    uint8               id;
    uint8array          debugdata;
});
PACKSTRUCT( struct gecko_msg_test_debug_counter_cmd_t
{
    uint32              id;
});
PACKSTRUCT( struct gecko_msg_test_debug_counter_rsp_t
{
    uint16              result;
    uint32              value;
});
PACKSTRUCT( struct gecko_msg_test_dtm_completed_evt_t
{
    uint16              result;
    uint16              number_of_packets;
});
PACKSTRUCT( struct gecko_msg_test_hcidump_evt_t
{
    uint32              time;
    uint8               direction;
    uint8               packet_type;
    uint16array         data;
});
PACKSTRUCT( struct gecko_msg_sm_set_bondable_mode_cmd_t
{
    uint8               bondable;
});
PACKSTRUCT( struct gecko_msg_sm_set_bondable_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_configure_cmd_t
{
    uint8               flags;
    uint8               io_capabilities;
});
PACKSTRUCT( struct gecko_msg_sm_configure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_store_bonding_configuration_cmd_t
{
    uint8               max_bonding_count;
    uint8               policy_flags;
});
PACKSTRUCT( struct gecko_msg_sm_store_bonding_configuration_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_increase_security_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_sm_increase_security_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_delete_bonding_cmd_t
{
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_sm_delete_bonding_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_delete_bondings_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_enter_passkey_cmd_t
{
    uint8               connection;
    int32               passkey;
});
PACKSTRUCT( struct gecko_msg_sm_enter_passkey_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_confirm_cmd_t
{
    uint8               connection;
    uint8               confirm;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_confirm_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_set_oob_data_cmd_t
{
    uint8array          oob_data;
});
PACKSTRUCT( struct gecko_msg_sm_set_oob_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_list_all_bondings_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_bonding_confirm_cmd_t
{
    uint8               connection;
    uint8               confirm;
});
PACKSTRUCT( struct gecko_msg_sm_bonding_confirm_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_set_debug_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_set_passkey_cmd_t
{
    int32               passkey;
});
PACKSTRUCT( struct gecko_msg_sm_set_passkey_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_use_sc_oob_cmd_t
{
    uint8               enable;
});
PACKSTRUCT( struct gecko_msg_sm_use_sc_oob_rsp_t
{
    uint16              result;
    uint8array          oob_data;
});
PACKSTRUCT( struct gecko_msg_sm_set_sc_remote_oob_data_cmd_t
{
    uint8array          oob_data;
});
PACKSTRUCT( struct gecko_msg_sm_set_sc_remote_oob_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_display_evt_t
{
    uint8               connection;
    uint32              passkey;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_request_evt_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_sm_confirm_passkey_evt_t
{
    uint8               connection;
    uint32              passkey;
});
PACKSTRUCT( struct gecko_msg_sm_bonded_evt_t
{
    uint8               connection;
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_sm_bonding_failed_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_sm_list_bonding_entry_evt_t
{
    uint8               bonding;
    bd_addr             address;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_sm_confirm_bonding_evt_t
{
    uint8               connection;
    int8                bonding_handle;
});
PACKSTRUCT( struct gecko_msg_homekit_configure_cmd_t
{
    uint8               i2c_address;
    uint8               support_display;
    uint8               hap_attribute_features;
    uint16              category;
    uint8               configuration_number;
    uint16              fast_advert_interval;
    uint16              fast_advert_timeout;
    uint32              flag;
    uint16              broadcast_advert_timeout;
});
PACKSTRUCT( struct gecko_msg_homekit_configure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_advertise_cmd_t
{
    uint8               enable;
    uint16              interval_min;
    uint16              interval_max;
    uint8               channel_map;
});
PACKSTRUCT( struct gecko_msg_homekit_advertise_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_delete_pairings_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_check_authcp_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_get_pairing_id_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_homekit_get_pairing_id_rsp_t
{
    uint16              result;
    uint8array          pairing_id;
});
PACKSTRUCT( struct gecko_msg_homekit_send_write_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               status_code;
});
PACKSTRUCT( struct gecko_msg_homekit_send_write_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_send_read_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               status_code;
    uint16              attribute_size;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_homekit_send_read_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_gsn_action_cmd_t
{
    uint8               action;
});
PACKSTRUCT( struct gecko_msg_homekit_gsn_action_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_event_notification_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               change_originator;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_homekit_event_notification_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_broadcast_action_cmd_t
{
    uint8               action;
    uint8array          params;
});
PACKSTRUCT( struct gecko_msg_homekit_broadcast_action_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_setupcode_display_evt_t
{
    uint8               connection;
    uint8array          setupcode;
});
PACKSTRUCT( struct gecko_msg_homekit_paired_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_pair_verified_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_connection_opened_evt_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_homekit_connection_closed_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_identify_evt_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_homekit_write_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              chr_value_size;
    uint16              authorization_size;
    uint16              value_offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_homekit_read_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
});
PACKSTRUCT( struct gecko_msg_homekit_disconnection_required_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_pairing_removed_evt_t
{
    uint8               connection;
    uint16              remaining_pairings;
    uint8array          pairing_id;
});
PACKSTRUCT( struct gecko_msg_homekit_setuppayload_display_evt_t
{
    uint8               connection;
    uint8array          setuppayload;
});
PACKSTRUCT( struct gecko_msg_coex_set_options_cmd_t
{
    uint32              mask;
    uint32              options;
});
PACKSTRUCT( struct gecko_msg_coex_set_options_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_coex_get_counters_cmd_t
{
    uint8               reset;
});
PACKSTRUCT( struct gecko_msg_coex_get_counters_rsp_t
{
    uint16              result;
    uint8array          counters;
});
PACKSTRUCT( struct gecko_msg_experiment_set_coded_phy_advertising_cmd_t
{
    uint8               handle;
    uint8               enable;
});
PACKSTRUCT( struct gecko_msg_experiment_set_coded_phy_advertising_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_experiment_set_coded_phy_discovery_cmd_t
{
    uint8               enable;
});
PACKSTRUCT( struct gecko_msg_experiment_set_coded_phy_discovery_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_user_message_to_target_cmd_t
{
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_user_message_to_target_rsp_t
{
    uint16              result;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_user_message_to_host_evt_t
{
    uint8array          data;
});


/**
 * The command packet type. This does not include the actual size of the byte array for user data in the end of the message.
 * The full size of a command packet is 4 + max bgapi payload size.
 */
PACKSTRUCT( struct gecko_cmd_packet
{
    uint32   header;

union{
    uint8 handle;
    struct gecko_msg_dfu_reset_cmd_t                             cmd_dfu_reset;
    struct gecko_msg_dfu_flash_set_address_cmd_t                 cmd_dfu_flash_set_address;
    struct gecko_msg_dfu_flash_set_address_rsp_t                 rsp_dfu_flash_set_address;
    struct gecko_msg_dfu_flash_upload_cmd_t                      cmd_dfu_flash_upload;
    struct gecko_msg_dfu_flash_upload_rsp_t                      rsp_dfu_flash_upload;
    struct gecko_msg_dfu_flash_upload_finish_rsp_t               rsp_dfu_flash_upload_finish;
    struct gecko_msg_dfu_boot_evt_t                              evt_dfu_boot;
    struct gecko_msg_dfu_boot_failure_evt_t                      evt_dfu_boot_failure;
    struct gecko_msg_system_hello_rsp_t                          rsp_system_hello;
    struct gecko_msg_system_reset_cmd_t                          cmd_system_reset;
    struct gecko_msg_system_get_bt_address_rsp_t                 rsp_system_get_bt_address;
    struct gecko_msg_system_set_bt_address_cmd_t                 cmd_system_set_bt_address;
    struct gecko_msg_system_set_bt_address_rsp_t                 rsp_system_set_bt_address;
    struct gecko_msg_system_set_tx_power_cmd_t                   cmd_system_set_tx_power;
    struct gecko_msg_system_set_tx_power_rsp_t                   rsp_system_set_tx_power;
    struct gecko_msg_system_get_random_data_cmd_t                cmd_system_get_random_data;
    struct gecko_msg_system_get_random_data_rsp_t                rsp_system_get_random_data;
    struct gecko_msg_system_halt_cmd_t                           cmd_system_halt;
    struct gecko_msg_system_halt_rsp_t                           rsp_system_halt;
    struct gecko_msg_system_set_device_name_cmd_t                cmd_system_set_device_name;
    struct gecko_msg_system_set_device_name_rsp_t                rsp_system_set_device_name;
    struct gecko_msg_system_linklayer_configure_cmd_t            cmd_system_linklayer_configure;
    struct gecko_msg_system_linklayer_configure_rsp_t            rsp_system_linklayer_configure;
    struct gecko_msg_system_boot_evt_t                           evt_system_boot;
    struct gecko_msg_system_external_signal_evt_t                evt_system_external_signal;
    struct gecko_msg_system_hardware_error_evt_t                 evt_system_hardware_error;
    struct gecko_msg_system_error_evt_t                          evt_system_error;
    struct gecko_msg_le_gap_open_cmd_t                           cmd_le_gap_open;
    struct gecko_msg_le_gap_open_rsp_t                           rsp_le_gap_open;
    struct gecko_msg_le_gap_set_mode_cmd_t                       cmd_le_gap_set_mode;
    struct gecko_msg_le_gap_set_mode_rsp_t                       rsp_le_gap_set_mode;
    struct gecko_msg_le_gap_discover_cmd_t                       cmd_le_gap_discover;
    struct gecko_msg_le_gap_discover_rsp_t                       rsp_le_gap_discover;
    struct gecko_msg_le_gap_end_procedure_rsp_t                  rsp_le_gap_end_procedure;
    struct gecko_msg_le_gap_set_adv_parameters_cmd_t             cmd_le_gap_set_adv_parameters;
    struct gecko_msg_le_gap_set_adv_parameters_rsp_t             rsp_le_gap_set_adv_parameters;
    struct gecko_msg_le_gap_set_conn_parameters_cmd_t            cmd_le_gap_set_conn_parameters;
    struct gecko_msg_le_gap_set_conn_parameters_rsp_t            rsp_le_gap_set_conn_parameters;
    struct gecko_msg_le_gap_set_scan_parameters_cmd_t            cmd_le_gap_set_scan_parameters;
    struct gecko_msg_le_gap_set_scan_parameters_rsp_t            rsp_le_gap_set_scan_parameters;
    struct gecko_msg_le_gap_set_adv_data_cmd_t                   cmd_le_gap_set_adv_data;
    struct gecko_msg_le_gap_set_adv_data_rsp_t                   rsp_le_gap_set_adv_data;
    struct gecko_msg_le_gap_set_adv_timeout_cmd_t                cmd_le_gap_set_adv_timeout;
    struct gecko_msg_le_gap_set_adv_timeout_rsp_t                rsp_le_gap_set_adv_timeout;
    struct gecko_msg_le_gap_set_phy_cmd_t                        cmd_le_gap_set_phy;
    struct gecko_msg_le_gap_set_phy_rsp_t                        rsp_le_gap_set_phy;
    struct gecko_msg_le_gap_bt5_set_mode_cmd_t                   cmd_le_gap_bt5_set_mode;
    struct gecko_msg_le_gap_bt5_set_mode_rsp_t                   rsp_le_gap_bt5_set_mode;
    struct gecko_msg_le_gap_bt5_set_adv_parameters_cmd_t         cmd_le_gap_bt5_set_adv_parameters;
    struct gecko_msg_le_gap_bt5_set_adv_parameters_rsp_t         rsp_le_gap_bt5_set_adv_parameters;
    struct gecko_msg_le_gap_bt5_set_adv_data_cmd_t               cmd_le_gap_bt5_set_adv_data;
    struct gecko_msg_le_gap_bt5_set_adv_data_rsp_t               rsp_le_gap_bt5_set_adv_data;
    struct gecko_msg_le_gap_set_privacy_mode_cmd_t               cmd_le_gap_set_privacy_mode;
    struct gecko_msg_le_gap_set_privacy_mode_rsp_t               rsp_le_gap_set_privacy_mode;
    struct gecko_msg_le_gap_scan_response_evt_t                  evt_le_gap_scan_response;
    struct gecko_msg_le_gap_scan_request_evt_t                   evt_le_gap_scan_request;
    struct gecko_msg_le_gap_bt5_adv_timeout_evt_t                evt_le_gap_bt5_adv_timeout;
    struct gecko_msg_le_connection_set_parameters_cmd_t          cmd_le_connection_set_parameters;
    struct gecko_msg_le_connection_set_parameters_rsp_t          rsp_le_connection_set_parameters;
    struct gecko_msg_le_connection_get_rssi_cmd_t                cmd_le_connection_get_rssi;
    struct gecko_msg_le_connection_get_rssi_rsp_t                rsp_le_connection_get_rssi;
    struct gecko_msg_le_connection_disable_slave_latency_cmd_t   cmd_le_connection_disable_slave_latency;
    struct gecko_msg_le_connection_disable_slave_latency_rsp_t   rsp_le_connection_disable_slave_latency;
    struct gecko_msg_le_connection_set_phy_cmd_t                 cmd_le_connection_set_phy;
    struct gecko_msg_le_connection_set_phy_rsp_t                 rsp_le_connection_set_phy;
    struct gecko_msg_le_connection_close_cmd_t                   cmd_le_connection_close;
    struct gecko_msg_le_connection_close_rsp_t                   rsp_le_connection_close;
    struct gecko_msg_le_connection_opened_evt_t                  evt_le_connection_opened;
    struct gecko_msg_le_connection_closed_evt_t                  evt_le_connection_closed;
    struct gecko_msg_le_connection_parameters_evt_t              evt_le_connection_parameters;
    struct gecko_msg_le_connection_rssi_evt_t                    evt_le_connection_rssi;
    struct gecko_msg_le_connection_phy_status_evt_t              evt_le_connection_phy_status;
    struct gecko_msg_le_connection_bt5_opened_evt_t              evt_le_connection_bt5_opened;
    struct gecko_msg_gatt_set_max_mtu_cmd_t                      cmd_gatt_set_max_mtu;
    struct gecko_msg_gatt_set_max_mtu_rsp_t                      rsp_gatt_set_max_mtu;
    struct gecko_msg_gatt_discover_primary_services_cmd_t        cmd_gatt_discover_primary_services;
    struct gecko_msg_gatt_discover_primary_services_rsp_t        rsp_gatt_discover_primary_services;
    struct gecko_msg_gatt_discover_primary_services_by_uuid_cmd_t cmd_gatt_discover_primary_services_by_uuid;
    struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t rsp_gatt_discover_primary_services_by_uuid;
    struct gecko_msg_gatt_discover_characteristics_cmd_t         cmd_gatt_discover_characteristics;
    struct gecko_msg_gatt_discover_characteristics_rsp_t         rsp_gatt_discover_characteristics;
    struct gecko_msg_gatt_discover_characteristics_by_uuid_cmd_t cmd_gatt_discover_characteristics_by_uuid;
    struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t rsp_gatt_discover_characteristics_by_uuid;
    struct gecko_msg_gatt_set_characteristic_notification_cmd_t  cmd_gatt_set_characteristic_notification;
    struct gecko_msg_gatt_set_characteristic_notification_rsp_t  rsp_gatt_set_characteristic_notification;
    struct gecko_msg_gatt_discover_descriptors_cmd_t             cmd_gatt_discover_descriptors;
    struct gecko_msg_gatt_discover_descriptors_rsp_t             rsp_gatt_discover_descriptors;
    struct gecko_msg_gatt_read_characteristic_value_cmd_t        cmd_gatt_read_characteristic_value;
    struct gecko_msg_gatt_read_characteristic_value_rsp_t        rsp_gatt_read_characteristic_value;
    struct gecko_msg_gatt_read_characteristic_value_by_uuid_cmd_t cmd_gatt_read_characteristic_value_by_uuid;
    struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t rsp_gatt_read_characteristic_value_by_uuid;
    struct gecko_msg_gatt_write_characteristic_value_cmd_t       cmd_gatt_write_characteristic_value;
    struct gecko_msg_gatt_write_characteristic_value_rsp_t       rsp_gatt_write_characteristic_value;
    struct gecko_msg_gatt_write_characteristic_value_without_response_cmd_t cmd_gatt_write_characteristic_value_without_response;
    struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t rsp_gatt_write_characteristic_value_without_response;
    struct gecko_msg_gatt_prepare_characteristic_value_write_cmd_t cmd_gatt_prepare_characteristic_value_write;
    struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t rsp_gatt_prepare_characteristic_value_write;
    struct gecko_msg_gatt_execute_characteristic_value_write_cmd_t cmd_gatt_execute_characteristic_value_write;
    struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t rsp_gatt_execute_characteristic_value_write;
    struct gecko_msg_gatt_send_characteristic_confirmation_cmd_t cmd_gatt_send_characteristic_confirmation;
    struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t rsp_gatt_send_characteristic_confirmation;
    struct gecko_msg_gatt_read_descriptor_value_cmd_t            cmd_gatt_read_descriptor_value;
    struct gecko_msg_gatt_read_descriptor_value_rsp_t            rsp_gatt_read_descriptor_value;
    struct gecko_msg_gatt_write_descriptor_value_cmd_t           cmd_gatt_write_descriptor_value;
    struct gecko_msg_gatt_write_descriptor_value_rsp_t           rsp_gatt_write_descriptor_value;
    struct gecko_msg_gatt_find_included_services_cmd_t           cmd_gatt_find_included_services;
    struct gecko_msg_gatt_find_included_services_rsp_t           rsp_gatt_find_included_services;
    struct gecko_msg_gatt_read_multiple_characteristic_values_cmd_t cmd_gatt_read_multiple_characteristic_values;
    struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t rsp_gatt_read_multiple_characteristic_values;
    struct gecko_msg_gatt_read_characteristic_value_from_offset_cmd_t cmd_gatt_read_characteristic_value_from_offset;
    struct gecko_msg_gatt_read_characteristic_value_from_offset_rsp_t rsp_gatt_read_characteristic_value_from_offset;
    struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_cmd_t cmd_gatt_prepare_characteristic_value_reliable_write;
    struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_rsp_t rsp_gatt_prepare_characteristic_value_reliable_write;
    struct gecko_msg_gatt_mtu_exchanged_evt_t                    evt_gatt_mtu_exchanged;
    struct gecko_msg_gatt_service_evt_t                          evt_gatt_service;
    struct gecko_msg_gatt_characteristic_evt_t                   evt_gatt_characteristic;
    struct gecko_msg_gatt_descriptor_evt_t                       evt_gatt_descriptor;
    struct gecko_msg_gatt_characteristic_value_evt_t             evt_gatt_characteristic_value;
    struct gecko_msg_gatt_descriptor_value_evt_t                 evt_gatt_descriptor_value;
    struct gecko_msg_gatt_procedure_completed_evt_t              evt_gatt_procedure_completed;
    struct gecko_msg_gatt_server_read_attribute_value_cmd_t      cmd_gatt_server_read_attribute_value;
    struct gecko_msg_gatt_server_read_attribute_value_rsp_t      rsp_gatt_server_read_attribute_value;
    struct gecko_msg_gatt_server_read_attribute_type_cmd_t       cmd_gatt_server_read_attribute_type;
    struct gecko_msg_gatt_server_read_attribute_type_rsp_t       rsp_gatt_server_read_attribute_type;
    struct gecko_msg_gatt_server_write_attribute_value_cmd_t     cmd_gatt_server_write_attribute_value;
    struct gecko_msg_gatt_server_write_attribute_value_rsp_t     rsp_gatt_server_write_attribute_value;
    struct gecko_msg_gatt_server_send_user_read_response_cmd_t   cmd_gatt_server_send_user_read_response;
    struct gecko_msg_gatt_server_send_user_read_response_rsp_t   rsp_gatt_server_send_user_read_response;
    struct gecko_msg_gatt_server_send_user_write_response_cmd_t  cmd_gatt_server_send_user_write_response;
    struct gecko_msg_gatt_server_send_user_write_response_rsp_t  rsp_gatt_server_send_user_write_response;
    struct gecko_msg_gatt_server_send_characteristic_notification_cmd_t cmd_gatt_server_send_characteristic_notification;
    struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t rsp_gatt_server_send_characteristic_notification;
    struct gecko_msg_gatt_server_find_attribute_cmd_t            cmd_gatt_server_find_attribute;
    struct gecko_msg_gatt_server_find_attribute_rsp_t            rsp_gatt_server_find_attribute;
    struct gecko_msg_gatt_server_set_database_cmd_t              cmd_gatt_server_set_database;
    struct gecko_msg_gatt_server_set_database_rsp_t              rsp_gatt_server_set_database;
    struct gecko_msg_gatt_server_set_capabilities_cmd_t          cmd_gatt_server_set_capabilities;
    struct gecko_msg_gatt_server_set_capabilities_rsp_t          rsp_gatt_server_set_capabilities;
    struct gecko_msg_gatt_server_attribute_value_evt_t           evt_gatt_server_attribute_value;
    struct gecko_msg_gatt_server_user_read_request_evt_t         evt_gatt_server_user_read_request;
    struct gecko_msg_gatt_server_user_write_request_evt_t        evt_gatt_server_user_write_request;
    struct gecko_msg_gatt_server_characteristic_status_evt_t     evt_gatt_server_characteristic_status;
    struct gecko_msg_gatt_server_execute_write_completed_evt_t   evt_gatt_server_execute_write_completed;
    struct gecko_msg_endpoint_close_cmd_t                        cmd_endpoint_close;
    struct gecko_msg_endpoint_close_rsp_t                        rsp_endpoint_close;
    struct gecko_msg_endpoint_status_evt_t                       evt_endpoint_status;
    struct gecko_msg_hardware_set_soft_timer_cmd_t               cmd_hardware_set_soft_timer;
    struct gecko_msg_hardware_set_soft_timer_rsp_t               rsp_hardware_set_soft_timer;
    struct gecko_msg_hardware_get_time_rsp_t                     rsp_hardware_get_time;
    struct gecko_msg_hardware_set_lazy_soft_timer_cmd_t          cmd_hardware_set_lazy_soft_timer;
    struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t          rsp_hardware_set_lazy_soft_timer;
    struct gecko_msg_hardware_enable_dcdc_cmd_t                  cmd_hardware_enable_dcdc;
    struct gecko_msg_hardware_enable_dcdc_rsp_t                  rsp_hardware_enable_dcdc;
    struct gecko_msg_hardware_soft_timer_evt_t                   evt_hardware_soft_timer;
    struct gecko_msg_flash_ps_dump_rsp_t                         rsp_flash_ps_dump;
    struct gecko_msg_flash_ps_erase_all_rsp_t                    rsp_flash_ps_erase_all;
    struct gecko_msg_flash_ps_save_cmd_t                         cmd_flash_ps_save;
    struct gecko_msg_flash_ps_save_rsp_t                         rsp_flash_ps_save;
    struct gecko_msg_flash_ps_load_cmd_t                         cmd_flash_ps_load;
    struct gecko_msg_flash_ps_load_rsp_t                         rsp_flash_ps_load;
    struct gecko_msg_flash_ps_erase_cmd_t                        cmd_flash_ps_erase;
    struct gecko_msg_flash_ps_erase_rsp_t                        rsp_flash_ps_erase;
    struct gecko_msg_flash_ps_key_evt_t                          evt_flash_ps_key;
    struct gecko_msg_test_dtm_tx_cmd_t                           cmd_test_dtm_tx;
    struct gecko_msg_test_dtm_tx_rsp_t                           rsp_test_dtm_tx;
    struct gecko_msg_test_dtm_rx_cmd_t                           cmd_test_dtm_rx;
    struct gecko_msg_test_dtm_rx_rsp_t                           rsp_test_dtm_rx;
    struct gecko_msg_test_dtm_end_rsp_t                          rsp_test_dtm_end;
    struct gecko_msg_test_debug_command_cmd_t                    cmd_test_debug_command;
    struct gecko_msg_test_debug_command_rsp_t                    rsp_test_debug_command;
    struct gecko_msg_test_debug_counter_cmd_t                    cmd_test_debug_counter;
    struct gecko_msg_test_debug_counter_rsp_t                    rsp_test_debug_counter;
    struct gecko_msg_test_dtm_completed_evt_t                    evt_test_dtm_completed;
    struct gecko_msg_test_hcidump_evt_t                          evt_test_hcidump;
    struct gecko_msg_sm_set_bondable_mode_cmd_t                  cmd_sm_set_bondable_mode;
    struct gecko_msg_sm_set_bondable_mode_rsp_t                  rsp_sm_set_bondable_mode;
    struct gecko_msg_sm_configure_cmd_t                          cmd_sm_configure;
    struct gecko_msg_sm_configure_rsp_t                          rsp_sm_configure;
    struct gecko_msg_sm_store_bonding_configuration_cmd_t        cmd_sm_store_bonding_configuration;
    struct gecko_msg_sm_store_bonding_configuration_rsp_t        rsp_sm_store_bonding_configuration;
    struct gecko_msg_sm_increase_security_cmd_t                  cmd_sm_increase_security;
    struct gecko_msg_sm_increase_security_rsp_t                  rsp_sm_increase_security;
    struct gecko_msg_sm_delete_bonding_cmd_t                     cmd_sm_delete_bonding;
    struct gecko_msg_sm_delete_bonding_rsp_t                     rsp_sm_delete_bonding;
    struct gecko_msg_sm_delete_bondings_rsp_t                    rsp_sm_delete_bondings;
    struct gecko_msg_sm_enter_passkey_cmd_t                      cmd_sm_enter_passkey;
    struct gecko_msg_sm_enter_passkey_rsp_t                      rsp_sm_enter_passkey;
    struct gecko_msg_sm_passkey_confirm_cmd_t                    cmd_sm_passkey_confirm;
    struct gecko_msg_sm_passkey_confirm_rsp_t                    rsp_sm_passkey_confirm;
    struct gecko_msg_sm_set_oob_data_cmd_t                       cmd_sm_set_oob_data;
    struct gecko_msg_sm_set_oob_data_rsp_t                       rsp_sm_set_oob_data;
    struct gecko_msg_sm_list_all_bondings_rsp_t                  rsp_sm_list_all_bondings;
    struct gecko_msg_sm_bonding_confirm_cmd_t                    cmd_sm_bonding_confirm;
    struct gecko_msg_sm_bonding_confirm_rsp_t                    rsp_sm_bonding_confirm;
    struct gecko_msg_sm_set_debug_mode_rsp_t                     rsp_sm_set_debug_mode;
    struct gecko_msg_sm_set_passkey_cmd_t                        cmd_sm_set_passkey;
    struct gecko_msg_sm_set_passkey_rsp_t                        rsp_sm_set_passkey;
    struct gecko_msg_sm_use_sc_oob_cmd_t                         cmd_sm_use_sc_oob;
    struct gecko_msg_sm_use_sc_oob_rsp_t                         rsp_sm_use_sc_oob;
    struct gecko_msg_sm_set_sc_remote_oob_data_cmd_t             cmd_sm_set_sc_remote_oob_data;
    struct gecko_msg_sm_set_sc_remote_oob_data_rsp_t             rsp_sm_set_sc_remote_oob_data;
    struct gecko_msg_sm_passkey_display_evt_t                    evt_sm_passkey_display;
    struct gecko_msg_sm_passkey_request_evt_t                    evt_sm_passkey_request;
    struct gecko_msg_sm_confirm_passkey_evt_t                    evt_sm_confirm_passkey;
    struct gecko_msg_sm_bonded_evt_t                             evt_sm_bonded;
    struct gecko_msg_sm_bonding_failed_evt_t                     evt_sm_bonding_failed;
    struct gecko_msg_sm_list_bonding_entry_evt_t                 evt_sm_list_bonding_entry;
    struct gecko_msg_sm_confirm_bonding_evt_t                    evt_sm_confirm_bonding;
    struct gecko_msg_homekit_configure_cmd_t                     cmd_homekit_configure;
    struct gecko_msg_homekit_configure_rsp_t                     rsp_homekit_configure;
    struct gecko_msg_homekit_advertise_cmd_t                     cmd_homekit_advertise;
    struct gecko_msg_homekit_advertise_rsp_t                     rsp_homekit_advertise;
    struct gecko_msg_homekit_delete_pairings_rsp_t               rsp_homekit_delete_pairings;
    struct gecko_msg_homekit_check_authcp_rsp_t                  rsp_homekit_check_authcp;
    struct gecko_msg_homekit_get_pairing_id_cmd_t                cmd_homekit_get_pairing_id;
    struct gecko_msg_homekit_get_pairing_id_rsp_t                rsp_homekit_get_pairing_id;
    struct gecko_msg_homekit_send_write_response_cmd_t           cmd_homekit_send_write_response;
    struct gecko_msg_homekit_send_write_response_rsp_t           rsp_homekit_send_write_response;
    struct gecko_msg_homekit_send_read_response_cmd_t            cmd_homekit_send_read_response;
    struct gecko_msg_homekit_send_read_response_rsp_t            rsp_homekit_send_read_response;
    struct gecko_msg_homekit_gsn_action_cmd_t                    cmd_homekit_gsn_action;
    struct gecko_msg_homekit_gsn_action_rsp_t                    rsp_homekit_gsn_action;
    struct gecko_msg_homekit_event_notification_cmd_t            cmd_homekit_event_notification;
    struct gecko_msg_homekit_event_notification_rsp_t            rsp_homekit_event_notification;
    struct gecko_msg_homekit_broadcast_action_cmd_t              cmd_homekit_broadcast_action;
    struct gecko_msg_homekit_broadcast_action_rsp_t              rsp_homekit_broadcast_action;
    struct gecko_msg_homekit_setupcode_display_evt_t             evt_homekit_setupcode_display;
    struct gecko_msg_homekit_paired_evt_t                        evt_homekit_paired;
    struct gecko_msg_homekit_pair_verified_evt_t                 evt_homekit_pair_verified;
    struct gecko_msg_homekit_connection_opened_evt_t             evt_homekit_connection_opened;
    struct gecko_msg_homekit_connection_closed_evt_t             evt_homekit_connection_closed;
    struct gecko_msg_homekit_identify_evt_t                      evt_homekit_identify;
    struct gecko_msg_homekit_write_request_evt_t                 evt_homekit_write_request;
    struct gecko_msg_homekit_read_request_evt_t                  evt_homekit_read_request;
    struct gecko_msg_homekit_disconnection_required_evt_t        evt_homekit_disconnection_required;
    struct gecko_msg_homekit_pairing_removed_evt_t               evt_homekit_pairing_removed;
    struct gecko_msg_homekit_setuppayload_display_evt_t          evt_homekit_setuppayload_display;
    struct gecko_msg_coex_set_options_cmd_t                      cmd_coex_set_options;
    struct gecko_msg_coex_set_options_rsp_t                      rsp_coex_set_options;
    struct gecko_msg_coex_get_counters_cmd_t                     cmd_coex_get_counters;
    struct gecko_msg_coex_get_counters_rsp_t                     rsp_coex_get_counters;
    struct gecko_msg_experiment_set_coded_phy_advertising_cmd_t  cmd_experiment_set_coded_phy_advertising;
    struct gecko_msg_experiment_set_coded_phy_advertising_rsp_t  rsp_experiment_set_coded_phy_advertising;
    struct gecko_msg_experiment_set_coded_phy_discovery_cmd_t    cmd_experiment_set_coded_phy_discovery;
    struct gecko_msg_experiment_set_coded_phy_discovery_rsp_t    rsp_experiment_set_coded_phy_discovery;
    struct gecko_msg_user_message_to_target_cmd_t                cmd_user_message_to_target;
    struct gecko_msg_user_message_to_target_rsp_t                rsp_user_message_to_target;
    struct gecko_msg_user_message_to_host_evt_t                  evt_user_message_to_host;

    uint8 *payload;
})data;
};

/**
 * Initialize BGAPI class dfu. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_dfu_init();

/**
 * Initialize BGAPI class system. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_system_init();

/**
 * Initialize BGAPI class le_gap. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_le_gap_init();

/**
 * Initialize BGAPI class le_connection. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_le_connection_init();

/**
 * Initialize BGAPI class gatt. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_gatt_init();

/**
 * Initialize BGAPI class gatt_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_gatt_server_init();

/**
 * Initialize BGAPI class endpoint. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_endpoint_init();

/**
 * Initialize BGAPI class hardware. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_hardware_init();

/**
 * Initialize BGAPI class flash. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_flash_init();

/**
 * Initialize BGAPI class test. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_test_init();

/**
 * Initialize BGAPI class sm. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_sm_init();

/**
 * Initialize BGAPI class coex. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_coex_init();

/**
 * Initialize BGAPI class experiment. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_experiment_init();
#include <em_gpio.h>

/**
 * Coexistence interface
 */

struct gecko_coexSignal {
  int interrupt;
  int pin;
  GPIO_Port_TypeDef port;
  bool polarity;
};

struct gecko_coexInit {
  uint32_t options;
  uint16_t requestWindow;
  uint16_t requestWindowCalibration;
  struct gecko_coexSignal requestSignal;
  struct gecko_coexSignal prioritySignal;
  struct gecko_coexSignal grantSignal;
};

#ifndef HAL_COEX_REQ_WINDOW
// Request window defines how many micro seconds earlier request signal
// is set before actual radio operation. Default value is defined here.
#define HAL_COEX_REQ_WINDOW 500
#endif

#ifndef HAL_COEX_REQ_BACKOFF
// Maximum backoff time in micro seconds after request signal is deasserted.
// This value needs to be smaller than request window.
#define HAL_COEX_REQ_BACKOFF 100
#endif

// Request window calibration value takes into account the hardware and
// software delayes which may delay the request signal
#if (HAL_COEX_REQ_SHARED)
#define GECKO_COEX_REQ_WINDOW_CALIBRATION   30
#else
#define GECKO_COEX_REQ_WINDOW_CALIBRATION   20
#endif

#define GECKO_COEXINIT_DEFAULT {               \
    0, /* configuration options */             \
    HAL_COEX_REQ_WINDOW,  /* request window */ \
    GECKO_COEX_REQ_WINDOW_CALIBRATION,         \
    {  /* request signal */                    \
      BSP_COEX_REQ_PIN,                        \
      BSP_COEX_REQ_PIN,                        \
      BSP_COEX_REQ_PORT,                       \
      BSP_COEX_REQ_ASSERT_LEVEL,               \
    },                                         \
    {  /* priority signal */                   \
      BSP_COEX_PRI_PIN,                        \
      BSP_COEX_PRI_PIN,                        \
      BSP_COEX_PRI_PORT,                       \
      BSP_COEX_PRI_ASSERT_LEVEL,               \
    },                                         \
    {  /* grant signal */                      \
      BSP_COEX_GNT_PIN,                        \
      BSP_COEX_GNT_PIN,                        \
      BSP_COEX_GNT_PORT,                       \
      BSP_COEX_GNT_ASSERT_LEVEL,               \
    },                                         \
}

#define GECKO_COEX_OPTION_REQUEST_BACKOFF_SHIFT 0
#define GECKO_COEX_OPTION_REQUEST_BACKOFF_MASK  0xff
#define GECKO_COEX_OPTION_REQUEST_BACKOFF_DEFAULT \
  HAL_COEX_REQ_BACKOFF
#define GECKO_COEX_OPTION_ENABLE_SHIFT          8
#define GECKO_COEX_OPTION_ENABLE                (1 << GECKO_COEX_OPTION_ENABLE_SHIFT)
#define GECKO_COEX_OPTION_SHARED_SHIFT          9
#define GECKO_COEX_OPTION_SHARED                (1 << GECKO_COEX_OPTION_SHARED_SHIFT)
#define GECKO_COEX_OPTION_TX_ABORT_SHIFT        10
#define GECKO_COEX_OPTION_TX_ABORT              (1 << GECKO_COEX_OPTION_TX_ABORT_SHIFT)
#define GECKO_COEX_OPTION_HIGH_PRIORITY_SHIFT   11
#define GECKO_COEX_OPTION_HIGH_PRIORITY         (1 << GECKO_COEX_OPTION_HIGH_PRIORITY_SHIFT)
#define GECKO_COEX_OPTION_MASK                  0x0000f00
#define GECKO_COEX_OPTION_REQUEST_WINDOW_SHIFT  16
#define GECKO_COEX_OPTION_REQUEST_WINDOW_MASK   0xffff0000

void gecko_initCoex(const struct gecko_coexInit *coexInit);
void gecko_setCoexOptions(uint32_t mask, uint32_t options);
void gecko_getCoexCounters(const void **ptr, uint8_t *size);

static inline void gecko_initCoexHAL()
{
#ifdef HAL_CONFIG
#if (HAL_COEX_ENABLE)
  // Set configuration options based on HAL config
  uint32_t options = 0;
  options |= GECKO_COEX_OPTION_REQUEST_BACKOFF_DEFAULT;
  options |= GECKO_COEX_OPTION_ENABLE;
#if (HAL_COEX_TX_HIPRI) || (HAL_COEX_RX_HIPRI)
  options |= GECKO_COEX_OPTION_HIGH_PRIORITY;
#endif
#if (HAL_COEX_TX_ABORT)
  options |= GECKO_COEX_OPTION_TX_ABORT;
#endif
#if (HAL_COEX_REQ_SHARED)
  options |= GECKO_COEX_OPTION_SHARED;
#endif
  // Initialise coexistence interface
  struct gecko_coexInit coexInit = GECKO_COEXINIT_DEFAULT;
  coexInit.options = options;
  gecko_initCoex(&coexInit);

#ifdef NATIVE_GECKO_H
  gecko_bgapi_class_coex_init();
#endif

#endif // HAL_COEX_ENABLE
#endif // HAL_CONFIG
}



/**
 * Initialize stack and all BGAPI classes.
 * This is a convenience method for getting the stack and all BGAPI classes usable by the application.
 * If application wants to initialize only a subset of BGAPI classes, this function should not be called. Instead,
 * first call gecko_stack_init() to initialize stack, and then call individual BGAPI class initializers.
 *
 * @param config if set as NULL uses default values for all configuration parameters
 */
static inline void gecko_init(const gecko_configuration_t *config)
{
    gecko_stack_init(config);

    gecko_bgapi_class_dfu_init();
    gecko_bgapi_class_system_init();
    gecko_bgapi_class_le_gap_init();
    gecko_bgapi_class_le_connection_init();
    gecko_bgapi_class_gatt_init();
    gecko_bgapi_class_gatt_server_init();
    gecko_bgapi_class_endpoint_init();
    gecko_bgapi_class_hardware_init();
    gecko_bgapi_class_flash_init();
    gecko_bgapi_class_test_init();
    gecko_bgapi_class_sm_init();
    gecko_bgapi_class_experiment_init();

    // Initialize coexistence interface. Parameters are taken from HAL config.
    gecko_initCoexHAL();
}

/** Forward declaration of internal command handling functions. Do not use those in application. **/
void sli_bt_cmd_dfu_reset(const void*);
void sli_bt_cmd_dfu_flash_set_address(const void*);
void sli_bt_cmd_dfu_flash_upload(const void*);
void sli_bt_cmd_dfu_flash_upload_finish(const void*);
void sli_bt_cmd_system_hello(const void*);
void sli_bt_cmd_system_reset(const void*);
void sli_bt_cmd_system_get_bt_address(const void*);
void sli_bt_cmd_system_set_bt_address(const void*);
void sli_bt_cmd_system_set_tx_power(const void*);
void sli_bt_cmd_system_get_random_data(const void*);
void sli_bt_cmd_system_halt(const void*);
void sli_bt_cmd_system_set_device_name(const void*);
void sli_bt_cmd_system_linklayer_configure(const void*);
void sli_bt_cmd_le_gap_open(const void*);
void sli_bt_cmd_le_gap_set_mode(const void*);
void sli_bt_cmd_le_gap_discover(const void*);
void sli_bt_cmd_le_gap_end_procedure(const void*);
void sli_bt_cmd_le_gap_set_adv_parameters(const void*);
void sli_bt_cmd_le_gap_set_conn_parameters(const void*);
void sli_bt_cmd_le_gap_set_scan_parameters(const void*);
void sli_bt_cmd_le_gap_set_adv_data(const void*);
void sli_bt_cmd_le_gap_set_adv_timeout(const void*);
void sli_bt_cmd_le_gap_set_phy(const void*);
void sli_bt_cmd_le_gap_bt5_set_mode(const void*);
void sli_bt_cmd_le_gap_bt5_set_adv_parameters(const void*);
void sli_bt_cmd_le_gap_bt5_set_adv_data(const void*);
void sli_bt_cmd_le_gap_set_privacy_mode(const void*);
void sli_bt_cmd_le_connection_set_parameters(const void*);
void sli_bt_cmd_le_connection_get_rssi(const void*);
void sli_bt_cmd_le_connection_disable_slave_latency(const void*);
void sli_bt_cmd_le_connection_set_phy(const void*);
void sli_bt_cmd_le_connection_close(const void*);
void sli_bt_cmd_gatt_set_max_mtu(const void*);
void sli_bt_cmd_gatt_discover_primary_services(const void*);
void sli_bt_cmd_gatt_discover_primary_services_by_uuid(const void*);
void sli_bt_cmd_gatt_discover_characteristics(const void*);
void sli_bt_cmd_gatt_discover_characteristics_by_uuid(const void*);
void sli_bt_cmd_gatt_set_characteristic_notification(const void*);
void sli_bt_cmd_gatt_discover_descriptors(const void*);
void sli_bt_cmd_gatt_read_characteristic_value(const void*);
void sli_bt_cmd_gatt_read_characteristic_value_by_uuid(const void*);
void sli_bt_cmd_gatt_write_characteristic_value(const void*);
void sli_bt_cmd_gatt_write_characteristic_value_without_response(const void*);
void sli_bt_cmd_gatt_prepare_characteristic_value_write(const void*);
void sli_bt_cmd_gatt_execute_characteristic_value_write(const void*);
void sli_bt_cmd_gatt_send_characteristic_confirmation(const void*);
void sli_bt_cmd_gatt_read_descriptor_value(const void*);
void sli_bt_cmd_gatt_write_descriptor_value(const void*);
void sli_bt_cmd_gatt_find_included_services(const void*);
void sli_bt_cmd_gatt_read_multiple_characteristic_values(const void*);
void sli_bt_cmd_gatt_read_characteristic_value_from_offset(const void*);
void sli_bt_cmd_gatt_prepare_characteristic_value_reliable_write(const void*);
void sli_bt_cmd_gatt_server_read_attribute_value(const void*);
void sli_bt_cmd_gatt_server_read_attribute_type(const void*);
void sli_bt_cmd_gatt_server_write_attribute_value(const void*);
void sli_bt_cmd_gatt_server_send_user_read_response(const void*);
void sli_bt_cmd_gatt_server_send_user_write_response(const void*);
void sli_bt_cmd_gatt_server_send_characteristic_notification(const void*);
void sli_bt_cmd_gatt_server_find_attribute(const void*);
void sli_bt_cmd_gatt_server_set_database(const void*);
void sli_bt_cmd_gatt_server_set_capabilities(const void*);
void sli_bt_cmd_endpoint_close(const void*);
void sli_bt_cmd_hardware_set_soft_timer(const void*);
void sli_bt_cmd_hardware_get_time(const void*);
void sli_bt_cmd_hardware_set_lazy_soft_timer(const void*);
void sli_bt_cmd_hardware_enable_dcdc(const void*);
void sli_bt_cmd_flash_ps_dump(const void*);
void sli_bt_cmd_flash_ps_erase_all(const void*);
void sli_bt_cmd_flash_ps_save(const void*);
void sli_bt_cmd_flash_ps_load(const void*);
void sli_bt_cmd_flash_ps_erase(const void*);
void sli_bt_cmd_test_dtm_tx(const void*);
void sli_bt_cmd_test_dtm_rx(const void*);
void sli_bt_cmd_test_dtm_end(const void*);
void sli_bt_cmd_test_debug_command(const void*);
void sli_bt_cmd_test_debug_counter(const void*);
void sli_bt_cmd_sm_set_bondable_mode(const void*);
void sli_bt_cmd_sm_configure(const void*);
void sli_bt_cmd_sm_store_bonding_configuration(const void*);
void sli_bt_cmd_sm_increase_security(const void*);
void sli_bt_cmd_sm_delete_bonding(const void*);
void sli_bt_cmd_sm_delete_bondings(const void*);
void sli_bt_cmd_sm_enter_passkey(const void*);
void sli_bt_cmd_sm_passkey_confirm(const void*);
void sli_bt_cmd_sm_set_oob_data(const void*);
void sli_bt_cmd_sm_list_all_bondings(const void*);
void sli_bt_cmd_sm_bonding_confirm(const void*);
void sli_bt_cmd_sm_set_debug_mode(const void*);
void sli_bt_cmd_sm_set_passkey(const void*);
void sli_bt_cmd_sm_use_sc_oob(const void*);
void sli_bt_cmd_sm_set_sc_remote_oob_data(const void*);
void sli_bt_cmd_homekit_configure(const void*);
void sli_bt_cmd_homekit_advertise(const void*);
void sli_bt_cmd_homekit_delete_pairings(const void*);
void sli_bt_cmd_homekit_check_authcp(const void*);
void sli_bt_cmd_homekit_get_pairing_id(const void*);
void sli_bt_cmd_homekit_send_write_response(const void*);
void sli_bt_cmd_homekit_send_read_response(const void*);
void sli_bt_cmd_homekit_gsn_action(const void*);
void sli_bt_cmd_homekit_event_notification(const void*);
void sli_bt_cmd_homekit_broadcast_action(const void*);
void sli_bt_cmd_coex_set_options(const void*);
void sli_bt_cmd_coex_get_counters(const void*);
void sli_bt_cmd_experiment_set_coded_phy_advertising(const void*);
void sli_bt_cmd_experiment_set_coded_phy_discovery(const void*);typedef void (*gecko_cmd_handler)(const void*);
void sli_bt_cmd_handler_delegate(uint32_t header, gecko_cmd_handler, const void*);

extern void*  gecko_cmd_msg_buf;
extern void*  gecko_rsp_msg_buf;

/** This command can be used to reset the system. This command does not have a response, but it triggers one of the boot events (normal reset or boot to DFU mode) after re-boot.  **/

static inline void* gecko_cmd_dfu_reset(uint8 dfu)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    
    gecko_cmd_msg->data.cmd_dfu_reset.dfu=dfu;
    gecko_cmd_msg->header=((gecko_cmd_dfu_reset_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_dfu_reset, &gecko_cmd_msg->data.payload);
    return 0;
}

/** After re-booting the local device into DFU mode, this command can be used to define the starting address on the flash to where the new firmware will be written in. **/

static inline struct gecko_msg_dfu_flash_set_address_rsp_t* gecko_cmd_dfu_flash_set_address(uint32 address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_dfu_flash_set_address.address=address;
    gecko_cmd_msg->header=((gecko_cmd_dfu_flash_set_address_id+((4)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_dfu_flash_set_address, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_dfu_flash_set_address;
}

/** This command can be used to upload the whole firmware image file into the Bluetooth device. The passed data length must be a multiple of 4 bytes. As the BGAPI command payload size is limited, multiple commands need to be issued one after the other until the whole .bin firmware image file is uploaded to the device. The next address of the flash sector in memory to write to is automatically updated by the bootloader after each individual command. **/

static inline struct gecko_msg_dfu_flash_upload_rsp_t* gecko_cmd_dfu_flash_upload(uint8 data_len, const uint8* data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_dfu_flash_upload.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_dfu_flash_upload;
    }

    
    gecko_cmd_msg->data.cmd_dfu_flash_upload.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_dfu_flash_upload.data.data,data_data,data_len);
    gecko_cmd_msg->header=((gecko_cmd_dfu_flash_upload_id+((1+data_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_dfu_flash_upload, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_dfu_flash_upload;
}

/** This command can be used to tell to the device that the DFU file has been fully uploaded. To return the device back to normal mode the command {a href="#cmd_dfu_reset"}DFU Reset {/a} must be issued next. **/

static inline struct gecko_msg_dfu_flash_upload_finish_rsp_t* gecko_cmd_dfu_flash_upload_finish()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_dfu_flash_upload_finish_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_dfu_flash_upload_finish, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_dfu_flash_upload_finish;
}

/** This command does not trigger any event but the response to the command is used to verify that communication between the host and the device is working. **/

static inline struct gecko_msg_system_hello_rsp_t* gecko_cmd_system_hello()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_system_hello_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_system_hello, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_hello;
}

/** 
            This command can be used to reset the system. It does not have a response, but it triggers one of the boot events (normal reset or boot to DFU mode) depending on the selected boot mode. **/

static inline void* gecko_cmd_system_reset(uint8 dfu)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    
    gecko_cmd_msg->data.cmd_system_reset.dfu=dfu;
    gecko_cmd_msg->header=((gecko_cmd_system_reset_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_system_reset, &gecko_cmd_msg->data.payload);
    return 0;
}

/** This command can be used to read the Bluetooth public address used by the device. **/

static inline struct gecko_msg_system_get_bt_address_rsp_t* gecko_cmd_system_get_bt_address()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_system_get_bt_address_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_system_get_bt_address, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_get_bt_address;
}

/** 
                This command can be used to set the Bluetooth public address used by the device. A valid address set with this command overrides the default Bluetooth public address programmed at production, and it will be effective in the next system reboot. The stack treats 00:00:00:00:00:00 and ff:ff:ff:ff:ff:ff as invalid addresses. Thus passing one of them into this command will cause the stack to use the default address in the next system reboot.
             **/

static inline struct gecko_msg_system_set_bt_address_rsp_t* gecko_cmd_system_set_bt_address(bd_addr address)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    memcpy(&gecko_cmd_msg->data.cmd_system_set_bt_address.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->header=((gecko_cmd_system_set_bt_address_id+((6)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_system_set_bt_address, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_set_bt_address;
}

/** 
                This command can be used to set the TX power. It returns the power that was set. If the GATT server contains a Tx Power service, the Tx Power Level attribute of the service will be updated accordingly.

                {p}{b}NOTE:{/b} This command should not be used while advertising, scanning or during connection.{/p}
             **/

static inline struct gecko_msg_system_set_tx_power_rsp_t* gecko_cmd_system_set_tx_power(int16 power)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_system_set_tx_power.power=power;
    gecko_cmd_msg->header=((gecko_cmd_system_set_tx_power_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_system_set_tx_power, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_set_tx_power;
}

/** 
                This command can be used to get random data up to 16 bytes.
             **/

static inline struct gecko_msg_system_get_random_data_rsp_t* gecko_cmd_system_get_random_data(uint8 length)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_system_get_random_data.length=length;
    gecko_cmd_msg->header=((gecko_cmd_system_get_random_data_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_system_get_random_data, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_get_random_data;
}

/** 
                This command forces radio to idle state and allows device to sleep. Advertising, scanning, connections and software timers are halted by this commands. Halted operations are resumed by calling this command with parameter 0. Connections stay alive if system is resumed before connection supervision timeout.
                {p}{b}NOTE:{/b}Software timer is also halted. Hardware interrupts are the only way to wake up from energy mode 2 when system is halted.{/p}
             **/

static inline struct gecko_msg_system_halt_rsp_t* gecko_cmd_system_halt(uint8 halt)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_system_halt.halt=halt;
    gecko_cmd_msg->header=((gecko_cmd_system_halt_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_system_halt, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_halt;
}

/** This command can be used to set the device name. Currently it is possible to set the name which will be used during the OTA update. The name will be stored in persistent storage.
            If the OTA device name is also set in gecko configuration, the name stored in persistent storage is overwritten with the name in gecko configuration during device boot. **/

static inline struct gecko_msg_system_set_device_name_rsp_t* gecko_cmd_system_set_device_name(uint8 type,uint8 name_len, const uint8* name_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)name_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_system_set_device_name.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_system_set_device_name;
    }

    
    gecko_cmd_msg->data.cmd_system_set_device_name.type=type;
    gecko_cmd_msg->data.cmd_system_set_device_name.name.len=name_len;
    memcpy(gecko_cmd_msg->data.cmd_system_set_device_name.name.data,name_data,name_len);
    gecko_cmd_msg->header=((gecko_cmd_system_set_device_name_id+((2+name_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_system_set_device_name, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_set_device_name;
}

/** Send configuration data to linklayer **/

static inline struct gecko_msg_system_linklayer_configure_rsp_t* gecko_cmd_system_linklayer_configure(uint8 key,uint8 data_len, const uint8* data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)data_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_system_linklayer_configure.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_system_linklayer_configure;
    }

    
    gecko_cmd_msg->data.cmd_system_linklayer_configure.key=key;
    gecko_cmd_msg->data.cmd_system_linklayer_configure.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_system_linklayer_configure.data.data,data_data,data_len);
    gecko_cmd_msg->header=((gecko_cmd_system_linklayer_configure_id+((2+data_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_system_linklayer_configure, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_system_linklayer_configure;
}

/** 
                {p}This command can be used to connect an advertising device.
                Scanning parameters can be configured with the
                le_gap_set_scan_parameters command before issuing this command.
                The Bluetooth stack will enter a state where it continuously
                scans for the connectable advertisement packets from the remote
                device which matches the Bluetooth address given as a
                parameter. Upon receiving the advertisement packet, the module
                will send a connection request packet to the target device to
                initiate a Bluetooth connection. To cancel an ongoing
                connection process use the {a href="#cmd_le_connection_close"}le_connection_close{/a} command with the
                handle received in the le_gap_open response.{/p}

                {p}A connection is opened in no-security mode. If the GATT
                client needs to read or write the attributes on GATT server
                requiring encryption or authentication, it must first encrypt
                the connection using an appropriate authentication method.{/p}

                {p}This command fails with "Connection Limit Exceeded" error if 
                the number of connections attempted to be opened exceeds the
                max_connections value configured.{/p}

                {p}Later calls of this command have to wait for the ongoing command
                 to complete. A received event 
                 {a href="#evt_le_connection_opened"}le_connection_opened{/a}
                 indicates connection opened successfully and a received event
                {a href="#evt_le_connection_closed"}le_connection_closed{/a} 
                indicates connection failures have occurred.
             **/

static inline struct gecko_msg_le_gap_open_rsp_t* gecko_cmd_le_gap_open(bd_addr address,uint8 address_type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    memcpy(&gecko_cmd_msg->data.cmd_le_gap_open.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->data.cmd_le_gap_open.address_type=address_type;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_open_id+((7)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_open, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_open;
}

/** This command can be used to configure the current Bluetooth LE GAP Connectable and Discoverable modes. It can be used to enable advertisements and/or allow incoming connections. To exit from this mode (to stop advertising and/or disallow incoming connections), issue this command with the Not Discoverable / Not Connectable parameter values.
            Command will take effect immediately. If currently set parameters can't be used with new mode then an error will be returned.
            {p}If advertisement will be enabled in user_data mode, {a href="#cmd_le_gap_set_adv_data"}le_gap_set_adv_data{/a} should be used to set advertisement and scan response data before issuing this command. When the advertisement is enabled in other modes than user_data, the advertisement and scan response data is generated by the stack using the following procedure:{/p}
            {p}
                {ol}
                    {li}Add a Flags field to advertisement data.{/li}
                    {li}Add a TX power level field to advertisement data if TX power service exists in the local GATT database.{/li}
                    {li}Add a Slave Connection Interval Range field to advertisement data if the GAP peripheral preferred connection parameters characteristic exists in the local GATT database.{/li}
                    {li}Add a list of 16-bit Service UUIDs to advertisement data if there are one or more 16-bit service UUIDs to advertise. The list is complete if all advertised 16-bit UUIDs are in advertisement data; otherwise the list is incomplete.{/li}
                    {li}Add a list of 128-bit service UUIDs to advertisement data if there are one or more 128-bit service UUIDs to advertise and there is still free space for this field. The list is complete if all advertised 128-bit UUIDs are in advertisement data; otherwise the list is incomplete. Note that an advertisement data packet can contain at most one 128-bit service UUID.{/li}
                    {li}Try to add the full local name to advertisement data if device is not in privacy mode. In case the full local name does not fit into the remaining free space, the advertised name is a shortened version by cutting off the end if the free space has at least 6 bytes; Otherwise, the local name is added to scan response data.{/li}
                {/ol}
            {/p}
            {p}This command fails with "Connection Limit Exceeded" error if the number of connections has reached the max_connections value configured.{/p}
             **/

static inline struct gecko_msg_le_gap_set_mode_rsp_t* gecko_cmd_le_gap_set_mode(uint8 discover,uint8 connect)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_mode.discover=discover;
    gecko_cmd_msg->data.cmd_le_gap_set_mode.connect=connect;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_set_mode_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_set_mode, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_mode;
}

/** This command can be used to start the GAP discovery procedure to scan for advertising devices, that is to perform a device discovery. Scanning parameters 
            can be configured with the {a href="#cmd_le_gap_set_scan_parameters"}le_gap_set_scan_parameters{/a} command before issuing this command. To cancel an ongoing 
            discovery process use the {a href="#cmd_le_gap_end_procedure"}le_gap_end_procedure{/a} command. **/

static inline struct gecko_msg_le_gap_discover_rsp_t* gecko_cmd_le_gap_discover(uint8 mode)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_discover.mode=mode;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_discover_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_discover, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_discover;
}

/** This command can be used to end a current GAP procedure. **/

static inline struct gecko_msg_le_gap_end_procedure_rsp_t* gecko_cmd_le_gap_end_procedure()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_le_gap_end_procedure_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_end_procedure, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_end_procedure;
}

/** This command can be used together with {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to set Bluetooth LE advertisement parameters. First, use this command to set advertisement parameters, and then use command {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to start or restart advertisement. If parameters can't be used with currently active mode an error will be returned. **/

static inline struct gecko_msg_le_gap_set_adv_parameters_rsp_t* gecko_cmd_le_gap_set_adv_parameters(uint16 interval_min,uint16 interval_max,uint8 channel_map)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.channel_map=channel_map;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_set_adv_parameters_id+((5)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_set_adv_parameters, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_adv_parameters;
}

/** This command can be used to set the default Bluetooth LE connection parameters. The configured values are valid for all subsequent connections that will 
            be established. For changing the parameters of an already established connection use the command {a href="#cmd_le_connection_set_parameters"}le_connection_set_parameters{/a}. **/

static inline struct gecko_msg_le_gap_set_conn_parameters_rsp_t* gecko_cmd_le_gap_set_conn_parameters(uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.min_interval=min_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.max_interval=max_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.latency=latency;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.timeout=timeout;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_set_conn_parameters_id+((8)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_set_conn_parameters, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_conn_parameters;
}

/** This command can be used to set Bluetooth LE scan parameters. If the device is currently scanning for advertising devices new parameters will take effect when the scanning is restarted. **/

static inline struct gecko_msg_le_gap_set_scan_parameters_rsp_t* gecko_cmd_le_gap_set_scan_parameters(uint16 scan_interval,uint16 scan_window,uint8 active)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.scan_interval=scan_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.scan_window=scan_window;
    gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.active=active;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_set_scan_parameters_id+((5)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_set_scan_parameters, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_scan_parameters;
}

/** This command can be used together with {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to advertise user defined data. First use this command to set the data in advertisement packets and/or in the scan response packets, and then use command {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to configure this device to be discoverable in user_data mode. 
                {p}Note that the user defined data may be overwritten by the system when this device is later configured to other discoverable mode than user_data. It is recommended to set both the advertisement data and scan response data at the same time.{/p}
                {p}If advertisement mode is currently active, then new advertisement data will be used immediately.{/p} **/

static inline struct gecko_msg_le_gap_set_adv_data_rsp_t* gecko_cmd_le_gap_set_adv_data(uint8 scan_rsp,uint8 adv_data_len, const uint8* adv_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)adv_data_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_le_gap_set_adv_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_le_gap_set_adv_data;
    }

    
    gecko_cmd_msg->data.cmd_le_gap_set_adv_data.scan_rsp=scan_rsp;
    gecko_cmd_msg->data.cmd_le_gap_set_adv_data.adv_data.len=adv_data_len;
    memcpy(gecko_cmd_msg->data.cmd_le_gap_set_adv_data.adv_data.data,adv_data_data,adv_data_len);
    gecko_cmd_msg->header=((gecko_cmd_le_gap_set_adv_data_id+((2+adv_data_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_set_adv_data, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_adv_data;
}

/** This command can be used together with {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to set the number of advertisements before stopping. Passing value 0 to this command will remove the timeout setting. **/

static inline struct gecko_msg_le_gap_set_adv_timeout_rsp_t* gecko_cmd_le_gap_set_adv_timeout(uint8 intervals)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_adv_timeout.intervals=intervals;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_set_adv_timeout_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_set_adv_timeout, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_adv_timeout;
}

/**  **/

static inline struct gecko_msg_le_gap_set_phy_rsp_t* gecko_cmd_le_gap_set_phy(uint8 phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_phy.phy=phy;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_set_phy_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_set_phy, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_phy;
}

/** This command is used to set one advertisement sets mode, this works the same way as {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} except has extra parameters to support Bluetooth 5 advertisement set and features **/

static inline struct gecko_msg_le_gap_bt5_set_mode_rsp_t* gecko_cmd_le_gap_bt5_set_mode(uint8 handle,uint8 discover,uint8 connect,uint16 maxevents,uint8 address_type)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.discover=discover;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.connect=connect;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.maxevents=maxevents;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.address_type=address_type;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_bt5_set_mode_id+((6)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_bt5_set_mode, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_mode;
}

/** This command can be used to set Bluetooth 5 LE advertisement parameters of an advertisement set that is specified by the given handle. These parameters are applied to the specified advertisement set only. Other advertisement sets are not affected.
            {p}This command is the same as {a href="#cmd_le_gap_set_adv_parameters"}le_gap_set_adv_parameters{/a} except it supports Bluetooth 5 extended features.{/p} **/

static inline struct gecko_msg_le_gap_bt5_set_adv_parameters_rsp_t* gecko_cmd_le_gap_bt5_set_adv_parameters(uint8 handle,uint16 interval_min,uint16 interval_max,uint8 channel_map,uint8 report_scan)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.channel_map=channel_map;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.report_scan=report_scan;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_bt5_set_adv_parameters_id+((7)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_bt5_set_adv_parameters, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_parameters;
}

/** Same as {a href="#cmd_le_gap_set_adv_data"}le_gap_set_adv_data{/a} except this command supports Bluetooth 5 advertisement sets **/

static inline struct gecko_msg_le_gap_bt5_set_adv_data_rsp_t* gecko_cmd_le_gap_bt5_set_adv_data(uint8 handle,uint8 scan_rsp,uint8 adv_data_len, const uint8* adv_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)adv_data_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_data;
    }

    
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.scan_rsp=scan_rsp;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.adv_data.len=adv_data_len;
    memcpy(gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.adv_data.data,adv_data_data,adv_data_len);
    gecko_cmd_msg->header=((gecko_cmd_le_gap_bt5_set_adv_data_id+((3+adv_data_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_bt5_set_adv_data, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_data;
}

/** 
            This command can be used to enable or disable privacy feature on all GAP roles. The new privacy mode will take effect for advertising on the next advertising enabling, for scanning on the next scan enabling, and for initiating on the next open connection command. When privacy is enabled and the device is advertising or scanning, the stack will maintain a periodic timer with the specified time interval as timeout value. At each timeout the stack will generate a new private resolvable address and use it in advertising data packets and scanning requests.
            {p}By default, privacy feature is disabled.{/p}
             **/

static inline struct gecko_msg_le_gap_set_privacy_mode_rsp_t* gecko_cmd_le_gap_set_privacy_mode(uint8 privacy,uint8 interval)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_gap_set_privacy_mode.privacy=privacy;
    gecko_cmd_msg->data.cmd_le_gap_set_privacy_mode.interval=interval;
    gecko_cmd_msg->header=((gecko_cmd_le_gap_set_privacy_mode_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_gap_set_privacy_mode, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_gap_set_privacy_mode;
}

/** This command can be used to request a change in the connection parameters of a Bluetooth LE connection. **/

static inline struct gecko_msg_le_connection_set_parameters_rsp_t* gecko_cmd_le_connection_set_parameters(uint8 connection,uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.min_interval=min_interval;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.max_interval=max_interval;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.latency=latency;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.timeout=timeout;
    gecko_cmd_msg->header=((gecko_cmd_le_connection_set_parameters_id+((9)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_connection_set_parameters, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_set_parameters;
}

/** This command can be used to get the latest RSSI value of a Bluetooth LE connection. **/

static inline struct gecko_msg_le_connection_get_rssi_rsp_t* gecko_cmd_le_connection_get_rssi(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_get_rssi.connection=connection;
    gecko_cmd_msg->header=((gecko_cmd_le_connection_get_rssi_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_connection_get_rssi, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_get_rssi;
}

/** This command temporarily enables or disables slave latency. Used only when Bluetooth device is in slave role. **/

static inline struct gecko_msg_le_connection_disable_slave_latency_rsp_t* gecko_cmd_le_connection_disable_slave_latency(uint8 connection,uint8 disable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_disable_slave_latency.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_disable_slave_latency.disable=disable;
    gecko_cmd_msg->header=((gecko_cmd_le_connection_disable_slave_latency_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_connection_disable_slave_latency, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_disable_slave_latency;
}

/** This command can be used to set preferred PHYs for connection. Preferred PHYs are connection specific. Event {a href="#evt_le_connection_phy_status"}le_connection_phy_status{/a} is received when PHY update procedure has been completed. Other than preferred PHY can also be set if remote device does not accept any of the preferred PHYs. {p}{b}NOTE:{/b} 2 Mbit and Coded PHYs are not supported by all devices.{/p} **/

static inline struct gecko_msg_le_connection_set_phy_rsp_t* gecko_cmd_le_connection_set_phy(uint8 connection,uint8 phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_set_phy.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_set_phy.phy=phy;
    gecko_cmd_msg->header=((gecko_cmd_le_connection_set_phy_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_connection_set_phy, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_set_phy;
}

/** This command can be used to close a Bluetooth LE connection or cancel an ongoing
                connection establishment process. The parameter is a connection handle which is reported in {a href="#evt_le_connection_opened"}le_connection_opened{/a} event or le_gap_open response. **/

static inline struct gecko_msg_le_connection_close_rsp_t* gecko_cmd_le_connection_close(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_le_connection_close.connection=connection;
    gecko_cmd_msg->header=((gecko_cmd_le_connection_close_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_le_connection_close, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_le_connection_close;
}

/** This command can be used to set the maximum size of ATT Message Transfer Units (MTU). If the given value is too large according to the maximum BGAPI payload size, the system will select the maximal possible value as the maximum ATT_MTU. If maximum ATT_MTU is larger than 23, MTU is exchanged automatically after Bluetooth LE connection has been established. **/

static inline struct gecko_msg_gatt_set_max_mtu_rsp_t* gecko_cmd_gatt_set_max_mtu(uint16 max_mtu)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_set_max_mtu.max_mtu=max_mtu;
    gecko_cmd_msg->header=((gecko_cmd_gatt_set_max_mtu_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_set_max_mtu, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_set_max_mtu;
}

/** This command can be used to discover all the primary services of a remote GATT database. This command generates a unique gatt_service event for 
            every discovered primary service. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure 
            has successfully completed or failed with error. **/

static inline struct gecko_msg_gatt_discover_primary_services_rsp_t* gecko_cmd_gatt_discover_primary_services(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_discover_primary_services.connection=connection;
    gecko_cmd_msg->header=((gecko_cmd_gatt_discover_primary_services_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_discover_primary_services, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services;
}

/** This command can be used to discover primary services with the specified UUID in a remote GATT database. This command generates unique gatt_service event for every discovered primary service. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error. **/

static inline struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t* gecko_cmd_gatt_discover_primary_services_by_uuid(uint8 connection,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid;
    }

    
    gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_discover_primary_services_by_uuid_id+((2+uuid_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_discover_primary_services_by_uuid, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid;
}

/** This command can be used to discover all characteristics of the defined GATT service from a remote GATT database. This command generates a unique gatt_characteristic event for every discovered characteristic. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error. **/

static inline struct gecko_msg_gatt_discover_characteristics_rsp_t* gecko_cmd_gatt_discover_characteristics(uint8 connection,uint32 service)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics.service=service;
    gecko_cmd_msg->header=((gecko_cmd_gatt_discover_characteristics_id+((5)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_discover_characteristics, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics;
}

/** This command can be used to discover all the characteristics of the specified GATT service in a remote GATT database having the specified UUID. This command
generates a unique gatt_characteristic event for every discovered
characteristic having the specified UUID. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that
this GATT procedure has successfully completed or failed with error.
             **/

static inline struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t* gecko_cmd_gatt_discover_characteristics_by_uuid(uint8 connection,uint32 service,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid;
    }

    
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.service=service;
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_discover_characteristics_by_uuid_id+((6+uuid_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_discover_characteristics_by_uuid, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid;
}

/** This command can be used to enable or disable the notifications and indications being sent from a remote GATT server. This procedure discovers a 
            characteristic client configuration descriptor and writes the related configuration flags to a remote GATT database. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event
            indicates that this GATT procedure has successfully completed or that is has failed with an error. **/

static inline struct gecko_msg_gatt_set_characteristic_notification_rsp_t* gecko_cmd_gatt_set_characteristic_notification(uint8 connection,uint16 characteristic,uint8 flags)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.flags=flags;
    gecko_cmd_msg->header=((gecko_cmd_gatt_set_characteristic_notification_id+((4)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_set_characteristic_notification, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_set_characteristic_notification;
}

/** This command can be used to discover all the descriptors of the specified remote GATT characteristics in a remote GATT database. This command generates a unique gatt_descriptor event for every discovered descriptor. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error. **/

static inline struct gecko_msg_gatt_discover_descriptors_rsp_t* gecko_cmd_gatt_discover_descriptors(uint8 connection,uint16 characteristic)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_discover_descriptors.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_descriptors.characteristic=characteristic;
    gecko_cmd_msg->header=((gecko_cmd_gatt_discover_descriptors_id+((3)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_discover_descriptors, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_discover_descriptors;
}

/** This command can be used to read the value of a characteristic from a remote GATT database. 
            A single {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value{/a} event is generated if the 
            characteristic value fits in one ATT PDU. Otherwise more than one {a href="#evt_gatt_characteristic_value"}
            gatt_characteristic_value{/a} events are generated because the firmware will automatically use the "read long" 
            GATT procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates
            that all data has been read successfully or that an error response has been received. **/

static inline struct gecko_msg_gatt_read_characteristic_value_rsp_t* gecko_cmd_gatt_read_characteristic_value(uint8 connection,uint16 characteristic)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value.characteristic=characteristic;
    gecko_cmd_msg->header=((gecko_cmd_gatt_read_characteristic_value_id+((3)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_read_characteristic_value, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value;
}

/** This command can be used to read the characteristic value of a service from a remote GATT database
            by giving the UUID of the characteristic and the handle of the service containing this characteristic. A single
            {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value{/a} event is generated if the characteristic
            value fits in one ATT PDU. Otherwise more than one {a href="#evt_gatt_characteristic_value"}
            gatt_characteristic_value{/a} events are generated because the firmware will automatically use the "read long" GATT procedure. 
            A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that all data has been read successfully or that an error response has been received. **/

static inline struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t* gecko_cmd_gatt_read_characteristic_value_by_uuid(uint8 connection,uint32 service,uint8 uuid_len, const uint8* uuid_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)uuid_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid;
    }

    
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.service=service;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_read_characteristic_value_by_uuid_id+((6+uuid_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_read_characteristic_value_by_uuid, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid;
}

/** This command can be used to write the value of a characteristic in a remote GATT database. If the given value does not fit in one ATT PDU, "write long" GATT procedure is used automatically. Received 
            {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that all data has been written successfully or that an error response 
            has been received. **/

static inline struct gecko_msg_gatt_write_characteristic_value_rsp_t* gecko_cmd_gatt_write_characteristic_value(uint8 connection,uint16 characteristic,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_write_characteristic_value.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value;
    }

    
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_write_characteristic_value_id+((4+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_write_characteristic_value, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value;
}

/** This command can be used to write the value of a characteristic in a
            remote GATT server. This command does not generate any event. All failures on the server are ignored silently. 
            For example, if an error is generated in the remote GATT server and the given value is not written into database no error message will be reported to the local 
            GATT client. Note that this command cannot be used to write long values. At most ATT_MTU - 3 amount of data can be sent once. **/

static inline struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t* gecko_cmd_gatt_write_characteristic_value_without_response(uint8 connection,uint16 characteristic,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response;
    }

    
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_write_characteristic_value_without_response_id+((4+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_write_characteristic_value_without_response, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response;
}

/** {p}This command can be used to add a characteristic value to the write queue of a remote GATT server. 
            This command can be used in cases where very long attributes need to be written, or a set of values needs to be written atomically. At most ATT_MTU - 5 amount of data can be sent once. Writes are executed or cancelled with the {a href="#cmd_gatt_execute_characteristic_value_write"}execute_characteristic_value_write{/a} command.
            Whether the writes succeeded or not are indicated in the response of the {a href="#cmd_gatt_execute_characteristic_value_write"}execute_characteristic_value_write{/a} command.{/p}
            {p}In all cases where the amount of data to transfer fits into the BGAPI payload the command 
            {a href="#cmd_gatt_write_characteristic_value"}gatt_write_characteristic_value{/a} is recommended for writing long values since it transparently 
            performs the prepare_write and execute_write commands.{/p}
             **/

static inline struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t* gecko_cmd_gatt_prepare_characteristic_value_write(uint8 connection,uint16 characteristic,uint16 offset,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write;
    }

    
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_prepare_characteristic_value_write_id+((6+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_prepare_characteristic_value_write, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write;
}

/** This command can be used to commit or cancel previously queued writes to a long characteristic of a remote GATT server.
            Writes are sent to queue with {a href="#cmd_gatt_prepare_characteristic_value_write"}prepare_characteristic_value_write{/a} command. 
            Content, offset and length of queued values are validated by this procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a}
            event indicates that all data has been written successfully or that an error response has been received.
             **/

static inline struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t* gecko_cmd_gatt_execute_characteristic_value_write(uint8 connection,uint8 flags)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_execute_characteristic_value_write.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_execute_characteristic_value_write.flags=flags;
    gecko_cmd_msg->header=((gecko_cmd_gatt_execute_characteristic_value_write_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_execute_characteristic_value_write, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_execute_characteristic_value_write;
}

/** This command must be used to send a characteristic confirmation to a remote GATT server after receiving an indication. 
            The {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value_event{/a} carries the att_opcode containing handle_value_indication (0x1d) which reveals 
            that an indication has been received and this must be confirmed with this command. Confirmation needs to be sent within 30 seconds, otherwise the GATT transactions 
            between the client and the server are discontinued. **/

static inline struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t* gecko_cmd_gatt_send_characteristic_confirmation(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_send_characteristic_confirmation.connection=connection;
    gecko_cmd_msg->header=((gecko_cmd_gatt_send_characteristic_confirmation_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_send_characteristic_confirmation, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_send_characteristic_confirmation;
}

/** This command can be used to read the descriptor value of a characteristic in a remote GATT database. A single {a href="#evt_gatt_descriptor_value"}
            gatt_descriptor_value{/a} event is generated if the descriptor value fits in one ATT PDU. Otherwise more than one {a href="#evt_gatt_descriptor_value"}gatt_descriptor_value{/a} events are generated because the firmware 
            will automatically use the "read long" GATT procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that all 
            data has been read successfully or that an error response has been received. **/

static inline struct gecko_msg_gatt_read_descriptor_value_rsp_t* gecko_cmd_gatt_read_descriptor_value(uint8 connection,uint16 descriptor)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_read_descriptor_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_descriptor_value.descriptor=descriptor;
    gecko_cmd_msg->header=((gecko_cmd_gatt_read_descriptor_value_id+((3)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_read_descriptor_value, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_read_descriptor_value;
}

/** This command can be used to write the value of a characteristic descriptor in a remote GATT database. If the given value does not fit in one ATT PDU, "write long" GATT procedure is used automatically. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} 
            event indicates that all data has been written succesfully or that an error response has been received.
             **/

static inline struct gecko_msg_gatt_write_descriptor_value_rsp_t* gecko_cmd_gatt_write_descriptor_value(uint8 connection,uint16 descriptor,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_write_descriptor_value.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_write_descriptor_value;
    }

    
    gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.descriptor=descriptor;
    gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_write_descriptor_value_id+((4+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_write_descriptor_value, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_write_descriptor_value;
}

/** This command can be used to find out if a service of a remote GATT database includes one or more other services. This command generates a unique gatt_service_completed event for each included service. This command generates a unique gatt_service event for every discovered service. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has successfully completed or failed with error. **/

static inline struct gecko_msg_gatt_find_included_services_rsp_t* gecko_cmd_gatt_find_included_services(uint8 connection,uint32 service)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_find_included_services.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_find_included_services.service=service;
    gecko_cmd_msg->header=((gecko_cmd_gatt_find_included_services_id+((5)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_find_included_services, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_find_included_services;
}

/** This command can be used to read the values of multiple characteristics from a remote GATT database at once. 
            {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value{/a} events are generated as the values are returned by the remote GATT server.
            A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that either all data has been read successfully or that an error response has been received. **/

static inline struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t* gecko_cmd_gatt_read_multiple_characteristic_values(uint8 connection,uint8 characteristic_list_len, const uint8* characteristic_list_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)characteristic_list_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values;
    }

    
    gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.characteristic_list.len=characteristic_list_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.characteristic_list.data,characteristic_list_data,characteristic_list_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_read_multiple_characteristic_values_id+((2+characteristic_list_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_read_multiple_characteristic_values, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values;
}

/** This command can be used to read a partial characteristic value with specified offset and maximum length 
            from a remote GATT database. It is equivalent to
            {a href="#cmd_gatt_read_characteristic_value"}gatt_read_characteristic_value{/a}
            if both the offset and maximum length parameters are 0.
            A single {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value{/a} event is generated 
            if the value to read fits in one ATT PDU. Otherwise more than one {a href="#evt_gatt_characteristic_value"}
            gatt_characteristic_value{/a} events are generated because the firmware will automatically use the "read long" 
            GATT procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates
            that all data has been read successfully or that an error response has been received. **/

static inline struct gecko_msg_gatt_read_characteristic_value_from_offset_rsp_t* gecko_cmd_gatt_read_characteristic_value_from_offset(uint8 connection,uint16 characteristic,uint16 offset,uint16 maxlen)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.maxlen=maxlen;
    gecko_cmd_msg->header=((gecko_cmd_gatt_read_characteristic_value_from_offset_id+((7)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_read_characteristic_value_from_offset, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_from_offset;
}

/** {p}This command can be used to add a characteristic value to the write queue of a remote GATT server and verify if the value was correctly received by the server. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error. Specifically, error code 0x0194 (data_corrupted) will be returned if the value received from the GATT server's response failed to pass the reliable write verification. At most ATT_MTU - 5 amount of data can be sent once. Writes are executed or cancelled with the {a href="#cmd_gatt_execute_characteristic_value_write"}execute_characteristic_value_write{/a} command.
            Whether the writes succeeded or not are indicated in the response of the {a href="#cmd_gatt_execute_characteristic_value_write"}execute_characteristic_value_write{/a} command.{/p}
             **/

static inline struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_rsp_t* gecko_cmd_gatt_prepare_characteristic_value_reliable_write(uint8 connection,uint16 characteristic,uint16 offset,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_reliable_write.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_reliable_write;
    }

    
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_prepare_characteristic_value_reliable_write_id+((6+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_prepare_characteristic_value_reliable_write, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_reliable_write;
}

/** This command can be used to read the value of an attribute from a local GATT database. Only (maximum BGAPI payload size - 3) amount of data can be read once. The application can continue reading with increased offset value if it receives (maximum BGAPI payload size - 3) amount of data. **/

static inline struct gecko_msg_gatt_server_read_attribute_value_rsp_t* gecko_cmd_gatt_server_read_attribute_value(uint16 attribute,uint16 offset)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_read_attribute_value.attribute=attribute;
    gecko_cmd_msg->data.cmd_gatt_server_read_attribute_value.offset=offset;
    gecko_cmd_msg->header=((gecko_cmd_gatt_server_read_attribute_value_id+((4)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_server_read_attribute_value, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_read_attribute_value;
}

/** This command can be used to read the type of an attribute from a local GATT database. The type is a UUID, usually 16 or 128 bits long. **/

static inline struct gecko_msg_gatt_server_read_attribute_type_rsp_t* gecko_cmd_gatt_server_read_attribute_type(uint16 attribute)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_read_attribute_type.attribute=attribute;
    gecko_cmd_msg->header=((gecko_cmd_gatt_server_read_attribute_type_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_server_read_attribute_type, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_read_attribute_type;
}

/** This command can be used to write the value of an attribute in the local GATT database. Writing the value of a characteristic of the local GATT database 
            will not trigger notifications or indications to the remote GATT client in case such characteristic has property of indicate or notify and the client has enabled 
            notification or indication. Notifications and indications are sent to the remote GATT client using {a href="#cmd_gatt_server_send_characteristic_notification"}
            gatt_server_send_characteristic_notification{/a} command. **/

static inline struct gecko_msg_gatt_server_write_attribute_value_rsp_t* gecko_cmd_gatt_server_write_attribute_value(uint16 attribute,uint16 offset,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value;
    }

    
    gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.attribute=attribute;
    gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_server_write_attribute_value_id+((5+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_server_write_attribute_value, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value;
}

/** This command must be used to send a response to a {a href="#evt_gatt_server_user_read_request"}user_read_request{/a} event. The response needs to be sent within 30 second, otherwise no more GATT 
            transactions are allowed by the remote side. If attr_errorcode is set to 0 the characteristic value is sent to the remote GATT client in the normal way. Other attr_errorcode 
            values will cause the local GATT server to send an attribute protocol error response instead of the actual data.
            At most ATT_MTU - 1 amount of data can be sent once. Client will continue reading by sending new read request with
            increased offset value if it receives ATT_MTU - 1 amount of data. **/

static inline struct gecko_msg_gatt_server_send_user_read_response_rsp_t* gecko_cmd_gatt_server_send_user_read_response(uint8 connection,uint16 characteristic,uint8 att_errorcode,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response;
    }

    
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.att_errorcode=att_errorcode;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_server_send_user_read_response_id+((5+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_server_send_user_read_response, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response;
}

/** This command must be used to send a response to a {a href="#evt_gatt_server_user_write_request"}gatt_server_user_write_request{/a} event when parameter att_opcode in the event is Write Request (see {a href="#enum_gatt_att_opcode"}att_opcode{/a}). The response needs to be sent within 30 seconds, otherwise no more GATT 
            transactions are allowed by the remote side. If attr_errorcode is set to 0 the ATT protocol's write response is sent to indicate to the remote GATT client that 
            the write operation was processed successfully. Other values will cause the local GATT server to send an ATT protocol error response. **/

static inline struct gecko_msg_gatt_server_send_user_write_response_rsp_t* gecko_cmd_gatt_server_send_user_write_response(uint8 connection,uint16 characteristic,uint8 att_errorcode)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.att_errorcode=att_errorcode;
    gecko_cmd_msg->header=((gecko_cmd_gatt_server_send_user_write_response_id+((4)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_server_send_user_write_response, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_send_user_write_response;
}

/** This command can be used to send notifications or indications to one or more remote GATT clients. At most ATT_MTU - 3 amount of data can be sent once.
            {p} A notification or indication is sent only if the client has enabled it by setting the corresponding flag to the Client Characteristic Configuration descriptor. In case the Client Characteristic Configuration descriptor supports both notification and indication, the stack will always send a notification even when the client has enabled both.{/p}
            {p}A new indication to a GATT client cannot be sent until an outstanding indication procedure with the same client has completed. The procedure is completed when a confirmation from the client has been received. The confirmation is indicated 
            by {a href="#evt_gatt_server_characteristic_status"}gatt_server_characteristic_status event{/a}.{/p} **/

static inline struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t* gecko_cmd_gatt_server_send_characteristic_notification(uint8 connection,uint16 characteristic,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification;
    }

    
    gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_server_send_characteristic_notification_id+((4+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_server_send_characteristic_notification, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification;
}

/** This command can be used to find attributes of certain type from a local GATT database. Type is usually given as 16-bit or 128-bit UUID. **/

static inline struct gecko_msg_gatt_server_find_attribute_rsp_t* gecko_cmd_gatt_server_find_attribute(uint16 start,uint8 type_len, const uint8* type_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)type_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_gatt_server_find_attribute.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_find_attribute;
    }

    
    gecko_cmd_msg->data.cmd_gatt_server_find_attribute.start=start;
    gecko_cmd_msg->data.cmd_gatt_server_find_attribute.type.len=type_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_find_attribute.type.data,type_data,type_len);
    gecko_cmd_msg->header=((gecko_cmd_gatt_server_find_attribute_id+((3+type_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_server_find_attribute, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_find_attribute;
}

/** 
            Deprecated. Use GATT capability feature for dynamic configuration of services and characteristics in the local GATT database. See {a href="#cmd_gatt_server_set_capabilities"}gatt_server_set_capabilities{/a} command for the details.
            {p}This command can be used to set the local GATT database. The database should not be changed while this device is connected as peripheral since it may cause GATT attributes and data synchronization problems. If the database is changed during advertising mode, advertisement packets will not be updated until the advertising is restarted.{/p} **/

static inline struct gecko_msg_gatt_server_set_database_rsp_t* gecko_cmd_gatt_server_set_database(uint32 ptr)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_set_database.ptr=ptr;
    gecko_cmd_msg->header=((gecko_cmd_gatt_server_set_database_id+((4)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_server_set_database, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_set_database;
}

/** 
                This command can be used to set which capabilities should be enabled in the local GATT database. A service is visible to remote GATT clients if at least one of its capabilities has been enabled. The same applies to a characteristic and its attributes. Capability identifiers and their corresponding bit flag values can be found in the auto-generated database header file. See UG118 for how to declare capabilities in GATT database.
                {p} Changing the capabilities of a database effectively causes a database change (attributes being added or removed) from a remote GATT client point of view. If the database has a Generic Attribute service and Service Changed characteristic, the stack will monitor local database change status and manage service changed indications for a GATT client that has enabled the indication configuration of the Service Changed characteristic.{/p}
             **/

static inline struct gecko_msg_gatt_server_set_capabilities_rsp_t* gecko_cmd_gatt_server_set_capabilities(uint32 caps,uint32 reserved)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_gatt_server_set_capabilities.caps=caps;
    gecko_cmd_msg->data.cmd_gatt_server_set_capabilities.reserved=reserved;
    gecko_cmd_msg->header=((gecko_cmd_gatt_server_set_capabilities_id+((8)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_gatt_server_set_capabilities, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_gatt_server_set_capabilities;
}

/** Deprecated. Use new command {a href="#cmd_le_connection_close"}le_connection_close{/a} to close Bluetooth LE connections.{p}This command can be used to close a Bluetooth LE connection. The parameter is a connection handle which is reported in event {a href="#evt_le_connection_opened"}le_connection_opened{/a}.{/p} **/

static inline struct gecko_msg_endpoint_close_rsp_t* gecko_cmd_endpoint_close(uint8 endpoint)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_endpoint_close.endpoint=endpoint;
    gecko_cmd_msg->header=((gecko_cmd_endpoint_close_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_endpoint_close, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_endpoint_close;
}

/** This command can be used to start a software timer. Multiple concurrent timers can be running simultaneously. There are 256 unique timer IDs available.
            The maximum number of concurrent timers is configurable at device initialization. Up to 16 concurrent timers can be configured. The default configuration is 4. As the RAM for storing timer data is pre-allocated at initialization, an application should not configure the amount more than it needs for minimizing RAM usage. **/

static inline struct gecko_msg_hardware_set_soft_timer_rsp_t* gecko_cmd_hardware_set_soft_timer(uint32 time,uint8 handle,uint8 single_shot)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_hardware_set_soft_timer.time=time;
    gecko_cmd_msg->data.cmd_hardware_set_soft_timer.handle=handle;
    gecko_cmd_msg->data.cmd_hardware_set_soft_timer.single_shot=single_shot;
    gecko_cmd_msg->header=((gecko_cmd_hardware_set_soft_timer_id+((6)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_hardware_set_soft_timer, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_hardware_set_soft_timer;
}

/** Deprecated. Get elapsed time since last reset of RTCC **/

static inline struct gecko_msg_hardware_get_time_rsp_t* gecko_cmd_hardware_get_time()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_hardware_get_time_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_hardware_get_time, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_hardware_get_time;
}

/** This command can be used to start a software timer with some slack. Slack parameter allows stack to optimize wake ups and save power. Timer event is triggered between time and time + slack. See also description of {a href="#cmd_hardware_set_soft_timer"}hardware_set_soft_timer{/a} command. **/

static inline struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t* gecko_cmd_hardware_set_lazy_soft_timer(uint32 time,uint32 slack,uint8 handle,uint8 single_shot)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.time=time;
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.slack=slack;
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.handle=handle;
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.single_shot=single_shot;
    gecko_cmd_msg->header=((gecko_cmd_hardware_set_lazy_soft_timer_id+((10)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_hardware_set_lazy_soft_timer, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_hardware_set_lazy_soft_timer;
}

/** Deprecated. This command can be used to enable or disable DC/DC. **/

static inline struct gecko_msg_hardware_enable_dcdc_rsp_t* gecko_cmd_hardware_enable_dcdc(uint8 enable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_hardware_enable_dcdc.enable=enable;
    gecko_cmd_msg->header=((gecko_cmd_hardware_enable_dcdc_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_hardware_enable_dcdc, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_hardware_enable_dcdc;
}

/** Deprecated. This command can be used to retrieve all PS keys and their current values. For each existing PS key a flash_pskey event will be generated which includes the corresponding PS key value.
            {p}This command is not recommended for dumping a large number of PS keys, as the system may have no enough memory for generating all flash_pskey events. The recommended solution is to retrieve the values by iterating {a href="#cmd_flash_ps_load"}ps_load{/a} command.{/p}
             **/

static inline struct gecko_msg_flash_ps_dump_rsp_t* gecko_cmd_flash_ps_dump()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_flash_ps_dump_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_flash_ps_dump, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_flash_ps_dump;
}

/** Deprecated. This command can be used to erase all PS keys and their corresponding values. **/

static inline struct gecko_msg_flash_ps_erase_all_rsp_t* gecko_cmd_flash_ps_erase_all()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_flash_ps_erase_all_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_flash_ps_erase_all, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_flash_ps_erase_all;
}

/** Deprecated. This command can be used to store a value into the specified PS key. Allowed PS keys are in range from 0x4000 to 0x407F. At most 56 bytes user data can be stored in one PS key. Error code 0x018a (command_too_long) will be returned if more than 56 bytes data is passed in. **/

static inline struct gecko_msg_flash_ps_save_rsp_t* gecko_cmd_flash_ps_save(uint16 key,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_flash_ps_save.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_flash_ps_save;
    }

    
    gecko_cmd_msg->data.cmd_flash_ps_save.key=key;
    gecko_cmd_msg->data.cmd_flash_ps_save.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_flash_ps_save.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_flash_ps_save_id+((3+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_flash_ps_save, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_flash_ps_save;
}

/** Deprecated. This command can be used for retrieving the value of the specified PS key. **/

static inline struct gecko_msg_flash_ps_load_rsp_t* gecko_cmd_flash_ps_load(uint16 key)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_flash_ps_load.key=key;
    gecko_cmd_msg->header=((gecko_cmd_flash_ps_load_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_flash_ps_load, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_flash_ps_load;
}

/** Deprecated. This command can be used to erase a single PS key and its value from the persistent store.. **/

static inline struct gecko_msg_flash_ps_erase_rsp_t* gecko_cmd_flash_ps_erase(uint16 key)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_flash_ps_erase.key=key;
    gecko_cmd_msg->header=((gecko_cmd_flash_ps_erase_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_flash_ps_erase, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_flash_ps_erase;
}

/** 
                This command can be used to start a transmitter test. The test is meant to be used against a separate Bluetooth tester device. When the command is processed by the radio, a {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event is triggered. This event indicates if the test started successfully.

                {p}In the transmitter test, the device sends packets continuously with a fixed interval. The type and length of each packet is set by {b}packet_type{/b} and {b}length{/b} parameters. Parameter {b}phy{/b} specifies which PHY is used to transmit the packets. All devices support at least the 1M PHY. There is also a special packet type, {b}test_pkt_carrier{/b}, which can be used to transmit continuous unmodulated carrier. The {b}length{/b} field is ignored in this mode.{/p}

                {p}The test may be stopped using the {a href="#cmd_test_dtm_end"}test_dtm_end{/a} command.{/p}
             **/

static inline struct gecko_msg_test_dtm_tx_rsp_t* gecko_cmd_test_dtm_tx(uint8 packet_type,uint8 length,uint8 channel,uint8 phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_test_dtm_tx.packet_type=packet_type;
    gecko_cmd_msg->data.cmd_test_dtm_tx.length=length;
    gecko_cmd_msg->data.cmd_test_dtm_tx.channel=channel;
    gecko_cmd_msg->data.cmd_test_dtm_tx.phy=phy;
    gecko_cmd_msg->header=((gecko_cmd_test_dtm_tx_id+((4)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_test_dtm_tx, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_test_dtm_tx;
}

/** 
                This command can be used to start a receiver test. The test is meant to be used against a separate Bluetooth tester device. When the command is processed by the radio, a {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event is triggered. This event indicates if the test started successfully.

                {p}Parameter {b}phy{/b} specifies which PHY is used to receive the packets. All devices support at least the 1M PHY.{/p}

                {p}The test may be stopped using the {a href="#cmd_test_dtm_end"}test_dtm_end{/a} command. This will trigger another {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event, which carries the number of packets received during the test.{/p}
             **/

static inline struct gecko_msg_test_dtm_rx_rsp_t* gecko_cmd_test_dtm_rx(uint8 channel,uint8 phy)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_test_dtm_rx.channel=channel;
    gecko_cmd_msg->data.cmd_test_dtm_rx.phy=phy;
    gecko_cmd_msg->header=((gecko_cmd_test_dtm_rx_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_test_dtm_rx, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_test_dtm_rx;
}

/** 
                This command can be used to end a transmitter or a receiver test. When the command is processed by the radio and the test has ended, a {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event is triggered.
             **/

static inline struct gecko_msg_test_dtm_end_rsp_t* gecko_cmd_test_dtm_end()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_test_dtm_end_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_test_dtm_end, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_test_dtm_end;
}

/** debug_command **/

static inline struct gecko_msg_test_debug_command_rsp_t* gecko_cmd_test_debug_command(uint8 id,uint8 debugdata_len, const uint8* debugdata_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)debugdata_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_test_debug_command.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_test_debug_command;
    }

    
    gecko_cmd_msg->data.cmd_test_debug_command.id=id;
    gecko_cmd_msg->data.cmd_test_debug_command.debugdata.len=debugdata_len;
    memcpy(gecko_cmd_msg->data.cmd_test_debug_command.debugdata.data,debugdata_data,debugdata_len);
    gecko_cmd_msg->header=((gecko_cmd_test_debug_command_id+((2+debugdata_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_test_debug_command, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_test_debug_command;
}

/** debug_counter **/

static inline struct gecko_msg_test_debug_counter_rsp_t* gecko_cmd_test_debug_counter(uint32 id)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_test_debug_counter.id=id;
    gecko_cmd_msg->header=((gecko_cmd_test_debug_counter_id+((4)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_test_debug_counter, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_test_debug_counter;
}

/** This command can be used to set whether the device accepts new bondings or not. **/

static inline struct gecko_msg_sm_set_bondable_mode_rsp_t* gecko_cmd_sm_set_bondable_mode(uint8 bondable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_set_bondable_mode.bondable=bondable;
    gecko_cmd_msg->header=((gecko_cmd_sm_set_bondable_mode_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_set_bondable_mode, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_bondable_mode;
}

/** This command can be used to configure security requirements and I/O capabilities of the system. **/

static inline struct gecko_msg_sm_configure_rsp_t* gecko_cmd_sm_configure(uint8 flags,uint8 io_capabilities)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_configure.flags=flags;
    gecko_cmd_msg->data.cmd_sm_configure.io_capabilities=io_capabilities;
    gecko_cmd_msg->header=((gecko_cmd_sm_configure_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_configure, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_configure;
}

/** This command can be used to set maximum allowed bonding count and bonding policy. The default value is maximum number of bondings supported. **/

static inline struct gecko_msg_sm_store_bonding_configuration_rsp_t* gecko_cmd_sm_store_bonding_configuration(uint8 max_bonding_count,uint8 policy_flags)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_store_bonding_configuration.max_bonding_count=max_bonding_count;
    gecko_cmd_msg->data.cmd_sm_store_bonding_configuration.policy_flags=policy_flags;
    gecko_cmd_msg->header=((gecko_cmd_sm_store_bonding_configuration_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_store_bonding_configuration, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_store_bonding_configuration;
}

/** This command can be used to enhance the security of a connection to current security requirements. On an unencrypted connection, this will encrypt the connection and will also perform bonding if requested by both devices. On an encrypted connection, this will cause the connection re-encrypted. **/

static inline struct gecko_msg_sm_increase_security_rsp_t* gecko_cmd_sm_increase_security(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_increase_security.connection=connection;
    gecko_cmd_msg->header=((gecko_cmd_sm_increase_security_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_increase_security, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_increase_security;
}

/** This command can be used to delete specified bonding information from Persistent Store. **/

static inline struct gecko_msg_sm_delete_bonding_rsp_t* gecko_cmd_sm_delete_bonding(uint8 bonding)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_delete_bonding.bonding=bonding;
    gecko_cmd_msg->header=((gecko_cmd_sm_delete_bonding_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_delete_bonding, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_delete_bonding;
}

/** This command can be used to delete all bonding information from Persistent Store. **/

static inline struct gecko_msg_sm_delete_bondings_rsp_t* gecko_cmd_sm_delete_bondings()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_sm_delete_bondings_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_delete_bondings, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_delete_bondings;
}

/** This command can be used to enter a passkey after receiving a passkey request event. **/

static inline struct gecko_msg_sm_enter_passkey_rsp_t* gecko_cmd_sm_enter_passkey(uint8 connection,int32 passkey)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_enter_passkey.connection=connection;
    gecko_cmd_msg->data.cmd_sm_enter_passkey.passkey=passkey;
    gecko_cmd_msg->header=((gecko_cmd_sm_enter_passkey_id+((5)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_enter_passkey, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_enter_passkey;
}

/** This command can be used for accepting or rejecting reported confirm value. **/

static inline struct gecko_msg_sm_passkey_confirm_rsp_t* gecko_cmd_sm_passkey_confirm(uint8 connection,uint8 confirm)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_passkey_confirm.connection=connection;
    gecko_cmd_msg->data.cmd_sm_passkey_confirm.confirm=confirm;
    gecko_cmd_msg->header=((gecko_cmd_sm_passkey_confirm_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_passkey_confirm, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_passkey_confirm;
}

/** 
                This command can be used to set the OOB data (out-of-band encryption data) for legacy pairing for a device. The OOB data may be, for example, a PIN code exchanged over 
                an alternate path like NFC. The device will not allow any other kind of bonding if OOB data is set. The OOB data cannot be set simultaneously with secure connections OOB data. 
             **/

static inline struct gecko_msg_sm_set_oob_data_rsp_t* gecko_cmd_sm_set_oob_data(uint8 oob_data_len, const uint8* oob_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)oob_data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_sm_set_oob_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_sm_set_oob_data;
    }

    
    gecko_cmd_msg->data.cmd_sm_set_oob_data.oob_data.len=oob_data_len;
    memcpy(gecko_cmd_msg->data.cmd_sm_set_oob_data.oob_data.data,oob_data_data,oob_data_len);
    gecko_cmd_msg->header=((gecko_cmd_sm_set_oob_data_id+((1+oob_data_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_set_oob_data, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_oob_data;
}

/** This command can be used to list all bondings stored in the bonding database. Bondings are reported by using the {a href="#evt_sm_list_bonding_entry"}
            sm_list_bonding_entry{/a} event for each bonding and the report is ended with {a href="#evt_sm_list_all_bondings_complete"}sm_list_all_bondings_complete{/a} event. 
            Recommended to be used only for debugging purposes, because reading from the Persistent Store is relatively slow. **/

static inline struct gecko_msg_sm_list_all_bondings_rsp_t* gecko_cmd_sm_list_all_bondings()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_sm_list_all_bondings_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_list_all_bondings, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_list_all_bondings;
}

/** This command can be used for accepting or rejecting bonding request. **/

static inline struct gecko_msg_sm_bonding_confirm_rsp_t* gecko_cmd_sm_bonding_confirm(uint8 connection,uint8 confirm)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_bonding_confirm.connection=connection;
    gecko_cmd_msg->data.cmd_sm_bonding_confirm.confirm=confirm;
    gecko_cmd_msg->header=((gecko_cmd_sm_bonding_confirm_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_bonding_confirm, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_bonding_confirm;
}

/** This command can be used to set Security Manager in debug mode. In this mode the secure connections bonding uses debug keys, so that the encrypted packet can be opened by Bluetooth protocol analyzer. To disable the debug mode, you need to restart the device. **/

static inline struct gecko_msg_sm_set_debug_mode_rsp_t* gecko_cmd_sm_set_debug_mode()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_sm_set_debug_mode_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_set_debug_mode, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_debug_mode;
}

/** This command can be used to enter a fixed passkey which will be used in the {a href="#evt_sm_passkey_display"}sm_passkey_display{/a} event. **/

static inline struct gecko_msg_sm_set_passkey_rsp_t* gecko_cmd_sm_set_passkey(int32 passkey)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_set_passkey.passkey=passkey;
    gecko_cmd_msg->header=((gecko_cmd_sm_set_passkey_id+((4)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_set_passkey, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_passkey;
}

/** 
                This command can be used to enable the use of OOB data (out-of-band encryption data) for a device for secure connections pairing.
                The enabling will genarate new OOB data and confirm values which can be sent to the remote device.
                After enabling the secure connections OOB data, the remote devices OOB data can be set with {a href="#cmd_sm_set_sc_remote_oob_data"}sm_set_sc_remote_oob_data{/a}.
                Calling this function will erase any set remote device OOB data and confirm values.
                The device will not allow any other kind of bonding if OOB data is set. The secure connections OOB data cannot be enabled simultaneously with legacy pairing OOB data.
             **/

static inline struct gecko_msg_sm_use_sc_oob_rsp_t* gecko_cmd_sm_use_sc_oob(uint8 enable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_sm_use_sc_oob.enable=enable;
    gecko_cmd_msg->header=((gecko_cmd_sm_use_sc_oob_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_use_sc_oob, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_use_sc_oob;
}

/** 
                This command can be used to set OOB data and confirm values (out-of-band encryption) received from the remote device for secure connections pairing.
                OOB data must be enabled with {a href="#cmd_sm_use_sc_oob"}sm_use_sc_oob{/a} before setting the remote device OOB data.
             **/

static inline struct gecko_msg_sm_set_sc_remote_oob_data_rsp_t* gecko_cmd_sm_set_sc_remote_oob_data(uint8 oob_data_len, const uint8* oob_data_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)oob_data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_sm_set_sc_remote_oob_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_sm_set_sc_remote_oob_data;
    }

    
    gecko_cmd_msg->data.cmd_sm_set_sc_remote_oob_data.oob_data.len=oob_data_len;
    memcpy(gecko_cmd_msg->data.cmd_sm_set_sc_remote_oob_data.oob_data.data,oob_data_data,oob_data_len);
    gecko_cmd_msg->header=((gecko_cmd_sm_set_sc_remote_oob_data_id+((1+oob_data_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_sm_set_sc_remote_oob_data, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_sm_set_sc_remote_oob_data;
}

/** This command can be used to configure the Apple HomeKit accessory and its settings. It is possible to reinitialize configuration in run time. New fast advertising parameters will be used for next fast advertising. **/

static inline struct gecko_msg_homekit_configure_rsp_t* gecko_cmd_homekit_configure(uint8 i2c_address,uint8 support_display,uint8 hap_attribute_features,uint16 category,uint8 configuration_number,uint16 fast_advert_interval,uint16 fast_advert_timeout,uint32 flag,uint16 broadcast_advert_timeout)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_homekit_configure.i2c_address=i2c_address;
    gecko_cmd_msg->data.cmd_homekit_configure.support_display=support_display;
    gecko_cmd_msg->data.cmd_homekit_configure.hap_attribute_features=hap_attribute_features;
    gecko_cmd_msg->data.cmd_homekit_configure.category=category;
    gecko_cmd_msg->data.cmd_homekit_configure.configuration_number=configuration_number;
    gecko_cmd_msg->data.cmd_homekit_configure.fast_advert_interval=fast_advert_interval;
    gecko_cmd_msg->data.cmd_homekit_configure.fast_advert_timeout=fast_advert_timeout;
    gecko_cmd_msg->data.cmd_homekit_configure.flag=flag;
    gecko_cmd_msg->data.cmd_homekit_configure.broadcast_advert_timeout=broadcast_advert_timeout;
    gecko_cmd_msg->header=((gecko_cmd_homekit_configure_id+((16)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_homekit_configure, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_configure;
}

/** This command can be used to start or stop Apple HomeKit accessory advertising. The command and parameters will take effect immediately. If the given parameters can't be used in the currently active mode, an error will be returned. **/

static inline struct gecko_msg_homekit_advertise_rsp_t* gecko_cmd_homekit_advertise(uint8 enable,uint16 interval_min,uint16 interval_max,uint8 channel_map)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_homekit_advertise.enable=enable;
    gecko_cmd_msg->data.cmd_homekit_advertise.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_homekit_advertise.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_homekit_advertise.channel_map=channel_map;
    gecko_cmd_msg->header=((gecko_cmd_homekit_advertise_id+((6)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_homekit_advertise, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_advertise;
}

/** This command can be used to delete all Apple HomeKit pairing data. **/

static inline struct gecko_msg_homekit_delete_pairings_rsp_t* gecko_cmd_homekit_delete_pairings()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_homekit_delete_pairings_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_homekit_delete_pairings, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_delete_pairings;
}

/** This command can be used to make an I2C test connection with Apple authentication co-processor and return error if communication failed. **/

static inline struct gecko_msg_homekit_check_authcp_rsp_t* gecko_cmd_homekit_check_authcp()
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->header=((gecko_cmd_homekit_check_authcp_id+((0)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_homekit_check_authcp, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_check_authcp;
}

/** This command can be used to get pairing ID of the connected iOS device. **/

static inline struct gecko_msg_homekit_get_pairing_id_rsp_t* gecko_cmd_homekit_get_pairing_id(uint8 connection)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_homekit_get_pairing_id.connection=connection;
    gecko_cmd_msg->header=((gecko_cmd_homekit_get_pairing_id_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_homekit_get_pairing_id, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_get_pairing_id;
}

/** This command can be used to send a response to a {a href="#evt_homekit_write_request"}homekit_write_request{/a} event. The response needs to be sent within 30 seconds, otherwise no more GATT 
            transactions are allowed by the remote side. 
            {br}{br}If the status_code is set to 0 the HAP will send a response informing that the write operation was processed successfully and other values will cause the HAP to send a HAP error status response. **/

static inline struct gecko_msg_homekit_send_write_response_rsp_t* gecko_cmd_homekit_send_write_response(uint8 connection,uint16 characteristic,uint8 status_code)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_homekit_send_write_response.connection=connection;
    gecko_cmd_msg->data.cmd_homekit_send_write_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_homekit_send_write_response.status_code=status_code;
    gecko_cmd_msg->header=((gecko_cmd_homekit_send_write_response_id+((4)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_homekit_send_write_response, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_send_write_response;
}

/** This command can be used to send a response to a {a href="#evt_homekit_read_request"}homekit_read_request{/a} event. The response needs to be sent within 30 seconds, or otherwise no more GATT transactions are allowed by the remote side.
            {br}{br}If {b}status_code{/b} is set to 0, the characteristic value is sent to the remote GATT client through HomeKit library in a normal way. Other {b}status_code{/b} values will cause a HAP error status response instead of the actual data being sent.
            {br}{br}If the value data size is less than attribute_size then the Apple HomeKit library will send new {a href="#evt_homekit_read_request"}homekit_read_request{/a} event with suitable offset. The Apple HomeKit library provides automatic formatting for the frame as well encryption. **/

static inline struct gecko_msg_homekit_send_read_response_rsp_t* gecko_cmd_homekit_send_read_response(uint8 connection,uint16 characteristic,uint8 status_code,uint16 attribute_size,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 7)
    {
        gecko_rsp_msg->data.rsp_homekit_send_read_response.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_homekit_send_read_response;
    }

    
    gecko_cmd_msg->data.cmd_homekit_send_read_response.connection=connection;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.status_code=status_code;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.attribute_size=attribute_size;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_homekit_send_read_response.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_homekit_send_read_response_id+((7+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_homekit_send_read_response, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_send_read_response;
}

/** This command can be used to make suitable action by HomeKit library for GSN (Global State Number) value. **/

static inline struct gecko_msg_homekit_gsn_action_rsp_t* gecko_cmd_homekit_gsn_action(uint8 action)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_homekit_gsn_action.action=action;
    gecko_cmd_msg->header=((gecko_cmd_homekit_gsn_action_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_homekit_gsn_action, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_gsn_action;
}

/** 
                This command can be used to perform suitable actions for HomeKit notifications according to a connection state and the originator of the change. When device is in connected state and it is local change it sends empty indication to controller. When device is disconnected it starts broadcast events advertising, next after timeout it starts fast advertising. Broadcast and fast advertising parameters are set in {a href="#cmd_homekit_configure"}homekit_configure{/a}. After fast advertising timeout it reverts previous advertising settings. For both states it sets suitable Global State Number value accoring to HomeKit specification rules.
             **/

static inline struct gecko_msg_homekit_event_notification_rsp_t* gecko_cmd_homekit_event_notification(uint8 connection,uint16 characteristic,uint8 change_originator,uint8 value_len, const uint8* value_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)value_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_homekit_event_notification.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_homekit_event_notification;
    }

    
    gecko_cmd_msg->data.cmd_homekit_event_notification.connection=connection;
    gecko_cmd_msg->data.cmd_homekit_event_notification.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_homekit_event_notification.change_originator=change_originator;
    gecko_cmd_msg->data.cmd_homekit_event_notification.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_homekit_event_notification.value.data,value_data,value_len);
    gecko_cmd_msg->header=((gecko_cmd_homekit_event_notification_id+((5+value_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_homekit_event_notification, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_event_notification;
}

/** This command can be used to make suitable action by HomeKit library for broadcast advertisisng. **/

static inline struct gecko_msg_homekit_broadcast_action_rsp_t* gecko_cmd_homekit_broadcast_action(uint8 action,uint8 params_len, const uint8* params_data)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    if ((uint16_t)params_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_homekit_broadcast_action.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_homekit_broadcast_action;
    }

    
    gecko_cmd_msg->data.cmd_homekit_broadcast_action.action=action;
    gecko_cmd_msg->data.cmd_homekit_broadcast_action.params.len=params_len;
    memcpy(gecko_cmd_msg->data.cmd_homekit_broadcast_action.params.data,params_data,params_len);
    gecko_cmd_msg->header=((gecko_cmd_homekit_broadcast_action_id+((2+params_len)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_homekit_broadcast_action, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_homekit_broadcast_action;
}

/** This command is used to configure coexistence options at runtime. **/

static inline struct gecko_msg_coex_set_options_rsp_t* gecko_cmd_coex_set_options(uint32 mask,uint32 options)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_coex_set_options.mask=mask;
    gecko_cmd_msg->data.cmd_coex_set_options.options=options;
    gecko_cmd_msg->header=((gecko_cmd_coex_set_options_id+((8)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_coex_set_options, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_coex_set_options;
}

/** This command is used to read coexistence statistic counters from the device. Response contains the list of uint32 type counter values. Counters in the list are in following order: low priority requested, high priority requested, low priority denied, high priority denied, low priority tx aborted, high priority tx aborted. **/

static inline struct gecko_msg_coex_get_counters_rsp_t* gecko_cmd_coex_get_counters(uint8 reset)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_coex_get_counters.reset=reset;
    gecko_cmd_msg->header=((gecko_cmd_coex_get_counters_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_coex_get_counters, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_coex_get_counters;
}

/** 
                {p}This command can be used to enable or disable Bluetooth LE coded PHY advertising.{/p}
                {p}This API command will change in the next release of the Bluetooth SDK and a replacing API command will be added to the GAP class.{/p}
                For a peripheral device to advertise with LE Coded PHY, the following commands need to be called:
                {ol}
                    {li}Allocate a unique Bluetooth 5 advertising set for the LE Coded PHY advertising.{/li}
                    {li}Call gecko_cmd_experiment_set_coded_phy_advertising(handle, 1) to enable LE Coded PHY advertising.{/li}
                    {li}Set advertising parameters with {a href="#cmd_le_gap_bt5_set_adv_parameters"}le_gap_bt5_set_adv_parameters{/a} command.{/li}
                    {li}Call {a href="#cmd_le_gap_bt5_set_mode"}le_gap_bt5_set_mode{/a} to start the advertiser.{/li}
                {/ol}
                {p}To disable this feature and use normal Bluetooth 4 style advertising, run the above procedure by calling gecko_cmd_experiment_set_coded_phy_advertising(handle, 0) in step 2.{/p}
             **/

static inline struct gecko_msg_experiment_set_coded_phy_advertising_rsp_t* gecko_cmd_experiment_set_coded_phy_advertising(uint8 handle,uint8 enable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_experiment_set_coded_phy_advertising.handle=handle;
    gecko_cmd_msg->data.cmd_experiment_set_coded_phy_advertising.enable=enable;
    gecko_cmd_msg->header=((gecko_cmd_experiment_set_coded_phy_advertising_id+((2)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_experiment_set_coded_phy_advertising, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_experiment_set_coded_phy_advertising;
}

/** 
                {p}This command can be used to enable or disable device discovery with LE Coded PHY.{/p}
                {p}This API command will change in the next release of the Bluetooth SDK and a replacing API command will be added to the GAP class.{/p}
                Use the following procedure to discover peripherals using LE Coded PHY advertising:
                {ol}
                    {li}Call gecko_cmd_experiment_set_coded_phy_discovery(1) to enable LE Coded PHY discovery.{/li}
                    {li}Set scan parameters with {a href="#cmd_le_gap_set_scan_parameters"}le_gap_set_scan_parameters{/a} command.{/li}
                    {li}Use {a href="#cmd_le_gap_discover"}le_gap_discover{/a} command to scan for the peripherals.{/li}
                {/ol}
                {p}To disable this feature and use normal Bluetooth 4 style device discovery, run the above procedure by calling gecko_cmd_experiment_set_coded_phy_discovery(0) in step 1.{/p}
             **/

static inline struct gecko_msg_experiment_set_coded_phy_discovery_rsp_t* gecko_cmd_experiment_set_coded_phy_discovery(uint8 enable)
{
    struct gecko_cmd_packet *gecko_cmd_msg = (struct gecko_cmd_packet *)gecko_cmd_msg_buf;
    struct gecko_cmd_packet *gecko_rsp_msg = (struct gecko_cmd_packet *)gecko_rsp_msg_buf;
    
    gecko_cmd_msg->data.cmd_experiment_set_coded_phy_discovery.enable=enable;
    gecko_cmd_msg->header=((gecko_cmd_experiment_set_coded_phy_discovery_id+((1)<<8)));
    
    sli_bt_cmd_handler_delegate(gecko_cmd_msg->header, sli_bt_cmd_experiment_set_coded_phy_discovery, &gecko_cmd_msg->data.payload);
    
    return &gecko_rsp_msg->data.rsp_experiment_set_coded_phy_discovery;
}
#ifdef __cplusplus
}
#endif

#endif
